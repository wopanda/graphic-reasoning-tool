<script>
// ====== æ€ç»´å¯¼å›¾æ•°æ®ç»“æ„ï¼ˆMarkdownæ ¼å¼ï¼‰ ======
// ç›´æ¥åœ¨ç¬¬ä¸€è¡Œä¿®æ”¹ï¼Œä¿å­˜ååˆ·æ–°é¡µé¢å³å¯ç”Ÿæ•ˆ

const mindmapMarkdown = `
- ğŸ¯ å›¾å½¢æ¨ç†å†³ç­–
    - ğŸš€ æ„æˆç›¸ä¼¼
      - ğŸ‘‰ å…ƒç´ å®Œå…¨ç›¸åŒ â‡’ [ä½ç½®è§„å¾‹]
        - å¹³ç§»
          * æ–¹å‘ (ç›´çº¿/æ›²çº¿/å¾€è¿”)
          * æ­¥æ•° (æ’å®š/é€’å¢/å¾ªç¯)
        - æ—‹è½¬
          * æ–¹å‘ (é¡ºæ—¶é’ˆ/é€†æ—¶é’ˆ)
          * è§’åº¦ (45Â°/90Â°/180Â°)
        - ç¿»è½¬
          * æ–¹å‘ (å·¦å³/ä¸Šä¸‹)
        - ç›¸é‚»æ¯”è¾ƒ
          * è§¦å‘ç‰¹å¾ï¼šæœ‰å…ƒç´ "ä¸åŠ¨"
          * æ£€æŸ¥ï¼šä½ç½®ã€å½¢çŠ¶ã€æ ·å¼çš„å˜åŒ–
      - ğŸ‘‰ å…ƒç´ éƒ¨åˆ†ç›¸åŒ â‡’ [æ ·å¼è§„å¾‹]
        - åŠ å‡åŒå¼‚ (è¿ç®—)
          * æ ¸å¿ƒï¼šä¼˜å…ˆéªŒè¯"æ±‚å¼‚"
          * æ±‚å¼‚ (ä¿ç•™ä¸åŒ)
          * æ±‚åŒ (ä¿ç•™ç›¸åŒ)
          * å åŠ  (ç›´æ¥ç›¸åŠ )
        - é»‘ç™½è¿ç®—
          * è§¦å‘ç‰¹å¾ï¼šå¸¦æ–¹æ ¼çš„é»‘ç™½å—
          * è¿ç®—é€»è¾‘ï¼šå¦‚ï¼šç™½+ç™½=ç™½, é»‘+é»‘=ç™½, é»‘+ç™½=é»‘
          * æŠ€å·§ï¼šæ‰¾"ç›¸åŒåŒºåŸŸ"è¿›è¡Œç§’æ€
        - æ ‡è®°è§„å¾‹
          * è§¦å‘ç‰¹å¾ï¼šæœ‰å­¤ç«‹çš„"å°æ ‡è®°"
          * æ£€æŸ¥ï¼šåˆ†ææ ‡è®°ä¸ä¸»ä½“/æ ‡è®°ä¹‹é—´çš„å…³ç³»
    - ğŸš€ æ„æˆå„å¼‚
      - ğŸ‘‰ ä¼˜å…ˆæŸ¥ [å±æ€§è§„å¾‹] (å®è§‚ç‰¹å¾)
        - å¯¹ç§°æ€§ (æœ€é«˜ä¼˜å…ˆçº§)
          * è½´å¯¹ç§° (æ£€æŸ¥: æ•°é‡, æ–¹å‘)
          * ä¸­å¿ƒå¯¹ç§°
          * è½´å¿ƒå…±å­˜
        - æ›²ç›´æ€§
          * è§¦å‘ç‰¹å¾ï¼šä¸€åŠä»¥ä¸Šå›¾å½¢å«æ›²çº¿
          * æ£€æŸ¥ï¼šå…¨ç›´çº¿ / å…¨æ›²çº¿ / æ›²ç›´å…±å­˜
        - å¼€é—­æ€§
          * è§¦å‘ç‰¹å¾ï¼š"ç”Ÿæ´»åŒ–"å›¾å½¢
          * æ£€æŸ¥ï¼šå…¨å¼€æ”¾ / å…¨å°é—­ / å¼€é—­äº¤æ›¿
        - å›¾å½¢é—´å…³ç³»
          * è§¦å‘ç‰¹å¾ï¼šå›¾å½¢ç”±2ä¸ªå…ƒç´ æ„æˆ
          * æ£€æŸ¥ï¼šç›¸ç¦» / ç›¸äº¤ / ç›¸åˆ‡ / åŒ…å«
      - ğŸ‘‰ æ— æ˜æ˜¾å±æ€§ï¼Œåˆ™æŸ¥ [æ•°é‡è§„å¾‹]
        - è¯†åˆ«å¼ºç‰¹å¾ (å¿«é€Ÿå®šä½è€ƒç‚¹)
          - æ—¥/ç”°/äº”è§’æ˜Ÿ/æ±‰å­—
            * æ•° [ç¬”ç”»]
          - å›¾å½¢æ•£ä¹±ã€ä¸è¿æ¥
            * æ•° [å…ƒç´ ]
          - æ ‡å‡†å‡ ä½•å›¾å½¢
            * æ•° [è§’(ç›´è§’ä¼˜å…ˆ)]
          - éƒ½æœ‰æ›²çº¿
            * æ•° [çº¿(æ›²/ç›´)] æˆ– [ç‚¹(äº¤ç‚¹)]
          - å†…éƒ¨ç›¸äº¤å¤æ‚
            * æ•° [ç‚¹(äº¤ç‚¹)] æˆ– [é¢]
        - æŒ‰åºæ’æŸ¥ (æ— å¼ºç‰¹å¾æ—¶çš„å…œåº•ç­–ç•¥)
          - 1. æ•° [é¢]
            - é¢çš„æ€»æ•°
            - ç»†åŒ– (å½“é¢çš„æ€»æ•°æ— è§„å¾‹)
              * æ‰€æœ‰é¢å½¢çŠ¶ä¸€è‡´? (å¦‚å…¨ä¸‰è§’)
              * å­˜åœ¨ä¸¤ç§é¢? (è€ƒæ•°é‡è¿ç®—)
              * åªæ•°ç‰¹å®šå½¢çŠ¶çš„é¢? (å¦‚åªæ•°ä¸‰è§’)
              * å­˜åœ¨å¤§å°é¢? (å¤§/å°é¢å•ç‹¬åˆ†æ)
          - 2. æ•° [çº¿]
            - çº¿çš„æ€»æ•°
            - ç»†åŒ– (å½“çº¿çš„æ€»æ•°æ— è§„å¾‹)
              * ç›´çº¿æ•° / æ›²çº¿æ•° (äºŒè€…å¯è¿ç®—)
              * æ¨ªçº¿æ•° / ç«–çº¿æ•° (äºŒè€…å¯è¿ç®—)
              * å¹³è¡Œçº¿ (ç»„æ•°/æ¡æ•°)
          - 3. æ•° [ç‚¹]
            - äº¤ç‚¹æ€»æ•° (çº¿æ¡ä¹‹é—´)
            - ç»†åŒ– (çœ‹ç‰¹å¾)
              * ç«¯ç‚¹æ€»æ•°
              * æ›²ç›´äº¤ç‚¹ / åˆ‡ç‚¹ / æ¡†ç‚¹ (å½“å›¾å½¢å«æ›²çº¿æ—¶)
          - 4. æ•° [ç¬”ç”»]
            - ä¸€ç¬”ç”» vs å¤šç¬”ç”»
              * åˆ¤æ–­ä¾æ®ï¼šå¥‡ç‚¹æ•° (0æˆ–2ä¸ºä¸€ç¬”ç”»)
          - 5. æ•° [å…ƒç´ ]
            - å…ƒç´ ç§ç±» / å…ƒç´ æ€»æ•°
            - ç»†åŒ– (çœ‹ç‰¹å¾)
                * éƒ¨åˆ†æ•° (æ•°ç‰¹å®šå°å…ƒç´ )
      - ğŸ‘‰ [é»‘ç™½å—] ç‰¹æ®Šå†³ç­–æ¨¡å—
        * 1. [å±æ€§] è§„åˆ™/å¥½çœ‹ â†’ æŸ¥ [å¯¹ç§°æ€§]
        * 2. [ä½ç½®] æ•°é‡å°‘/é¢ç§¯å¤§ â†’ æŸ¥ [ä½ç½®è§„å¾‹]
        * 3. [æ•°é‡] åˆ†å †å°‘ â†’ æŸ¥ [éƒ¨åˆ†æ•°]
        * 4. [æ ·å¼] åˆ†å †å¤š/ä¹å®«æ ¼ â†’ æŸ¥ [é»‘ç™½è¿ç®—]
        * 5. [æ•°é‡] (æœ€åè€ƒè™‘) â†’ æŸ¥ é»‘å—/ç™½å— [ä¸ªæ•°]
`.trim();
</script>

<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å›¾Â·å¢ƒ - å›¾å½¢æ¨ç†æ€ç»´å¯¼å›¾</title>
    <style>
        /* åŸºç¡€é‡ç½®ä¸å­—ä½“ */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            color: #333333;
            line-height: 1.6;
            overflow: hidden;
            height: 100vh;
        }

        /* ä¸»å®¹å™¨ */
        .slate {
            width: 100vw;
            height: 100vh;
            position: relative;
            overflow: hidden;
        }

        /* æ€ç»´å¯¼å›¾ç”»å¸ƒ */
        .mindmap-canvas {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            cursor: grab;
            overflow: hidden;
            /* è§¦æ‘¸ä¼˜åŒ– */
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }

        .mindmap-canvas.dragging {
            cursor: grabbing;
        }

        /* æ€ç»´å¯¼å›¾å®¹å™¨ - ç®€åŒ–çš„æ¨ªå‘å¸ƒå±€ */
        .mindmap-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform-origin: 0 0;
            transition: transform 0.3s ease-out;
            padding: 60px;
        }

        /* å¡ç‰‡æ ·å¼ - Gingkoé£æ ¼ */
        .card {
            position: absolute;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.08);
            border: 1px solid #e1e8ed;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            width: 240px;
            overflow: hidden;
            /* è§¦æ‘¸ä¼˜åŒ– */
            touch-action: manipulation;
            -webkit-tap-highlight-color: rgba(0, 122, 255, 0.1);
        }

        .card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.12);
            border-color: #007AFF;
        }

        .card.active {
            border-color: #007AFF;
            box-shadow: 0 4px 20px rgba(0, 122, 255, 0.2);
            transform: translateY(-2px);
        }

        .card.active::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 4px;
            background: linear-gradient(135deg, #007AFF, #0056CC);
        }

        /* å¡ç‰‡å†…å®¹ */
        .card-content {
            padding: 16px 32px 16px 20px; /* å‡å°‘å³ä¾§å†…è¾¹è·åˆ°32pxï¼Œè®©æ–‡å­—å’Œæ•°å­—æ›´è¿‘ */
            font-size: 14px;
            font-weight: 500;
            color: #333;
            line-height: 1.4;
        }

        /* æ ¹èŠ‚ç‚¹å¡ç‰‡ */
        .card.root-card {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            max-width: 280px;
        }

        .card.root-card .card-content {
            font-size: 18px;
            font-weight: 600;
            padding: 24px 40px 24px 28px; /* å‡å°‘æ ¹èŠ‚ç‚¹å³ä¾§å†…è¾¹è· */
            text-align: center;
            color: white;
        }

        .card.root-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 25px rgba(102, 126, 234, 0.3);
        }

        /* ä¸€çº§åˆ†æ”¯å¡ç‰‡ */
        .card.branch-card {
            background: linear-gradient(135deg, #a8edea, #fed6e3);
            border: none;
        }

        .card.branch-card .card-content {
            font-size: 15px;
            font-weight: 600;
            color: #2d3748;
        }

        .card.branch-card.active {
            background: linear-gradient(135deg, #81e6d9, #fbb6ce);
        }

        /* å¶èŠ‚ç‚¹å¡ç‰‡ */
        .card.leaf-card {
            background: white;
        }

        .card.leaf-card .card-content {
            font-size: 13px;
            font-weight: 400;
            color: #4a5568;
        }

        /* æ¢ç´¢çŠ¶æ€çš„å¡ç‰‡ - èƒŒæ™¯å±‚ */
        .card.exploration {
            opacity: 0.4;
            background: #F8F9FA;
            border: 1px solid #E5E7EB;
            transform: scale(0.95);
            z-index: 1;
            transition: all 0.3s ease;
        }

        .card.exploration .card-content {
            color: #9CA3AF;
            font-size: 12px;
        }

        /* æ¢ç´¢å¡ç‰‡æ‚¬åœæ•ˆæœ */
        .card.exploration:hover,
        .card.exploration.highlighted {
            opacity: 0.8;
            transform: scale(1);
            background: #F3F4F6;
            border-color: #9CA3AF;
            z-index: 5;
        }

        .card.exploration:hover .card-content,
        .card.exploration.highlighted .card-content {
            color: #6B7280;
            font-size: 13px;
        }

        /* è§£å†³æ–¹æ¡ˆçŠ¶æ€çš„å¡ç‰‡ - ç»“æœå±‚ï¼ˆæœ€é«˜ä¼˜å…ˆçº§ï¼‰ */
        .card.solution {
            background: linear-gradient(135deg, #FEF3C7, #FDE68A);
            border: 2px solid #F59E0B;
            box-shadow: 0 4px 20px rgba(245, 158, 11, 0.3);
            z-index: 10;
            transform: scale(1.02);
        }

        .card.solution .card-content {
            color: #92400E;
            font-weight: 600;
        }

        /* æœç´¢åŒ¹é…çŠ¶æ€çš„å¡ç‰‡ - æœç´¢ç»“æœå±‚ */
        .card.search-match {
            background: linear-gradient(135deg, #E0F2FE, #BAE6FD);
            border: 2px solid #0EA5E9;
            box-shadow: 0 4px 20px rgba(14, 165, 233, 0.3);
            z-index: 12;
            transform: scale(1.05);
            animation: searchPulse 2s ease-in-out infinite;
        }

        .card.search-match .card-content {
            color: #0C4A6E;
            font-weight: 600;
        }

        /* æœç´¢è·¯å¾„ä¸­çš„å¡ç‰‡ */
        .card.search-path {
            background: linear-gradient(135deg, #F0F9FF, #E0F2FE);
            border: 2px solid #0284C7;
            box-shadow: 0 3px 15px rgba(2, 132, 199, 0.2);
            z-index: 11;
            transform: scale(1.02);
        }

        .card.search-path .card-content {
            color: #164E63;
            font-weight: 500;
        }

        /* æœç´¢è„‰åŠ¨åŠ¨ç”» */
        @keyframes searchPulse {
            0%, 100% {
                transform: scale(1.05);
                box-shadow: 0 4px 20px rgba(14, 165, 233, 0.3);
            }
            50% {
                transform: scale(1.08);
                box-shadow: 0 6px 25px rgba(14, 165, 233, 0.5);
            }
        }

        /* å½“å‰æ´»è·ƒå¡ç‰‡ - äº¤äº’å±‚ */
        .card.active {
            z-index: 8;
        }

        /* é”®ç›˜ç„¦ç‚¹çŠ¶æ€ */
        .card.keyboard-focused {
            outline: 3px solid #007AFF;
            outline-offset: 2px;
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 6px 24px rgba(0, 122, 255, 0.25);
            transition: all 0.2s ease;
            z-index: 9;
        }

        .card.keyboard-focused.exploration {
            outline-color: #6B7280;
            box-shadow: 0 6px 24px rgba(107, 114, 128, 0.25);
        }

        .card.keyboard-focused.solution {
            outline-color: #F59E0B;
            box-shadow: 0 6px 24px rgba(245, 158, 11, 0.4);
        }

        /* å±•å¼€æŒ‡ç¤ºå™¨ */
        .expand-indicator {
            position: absolute;
            right: 8px; /* ç¨å¾®å‘å³ç§»åŠ¨ä¸€ç‚¹ */
            top: 50%;
            transform: translateY(-50%);
            width: 22px; /* ç¨å¾®å‡å°å°ºå¯¸ */
            height: 22px;
            border-radius: 50%;
            background: #f7fafc;
            border: 2px solid #e2e8f0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px; /* æ¢å¤åŸæ¥çš„å­—ä½“å¤§å° */
            font-weight: bold;
            color: #718096;
            transition: all 0.3s ease;
            z-index: 10; /* ç¡®ä¿æŒ‡ç¤ºå™¨åœ¨æœ€ä¸Šå±‚ */
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1); /* æ·»åŠ è½»å¾®é˜´å½± */
        }

        .card:hover .expand-indicator {
            background: #007AFF;
            border-color: #007AFF;
            color: white;
        }

        .card.active .expand-indicator {
            background: #007AFF;
            border-color: #007AFF;
            color: white;
        }

        /* æ£€æŸ¥æ¸…å•æŒ‡ç¤ºå™¨ */
        .checklist-indicator {
            position: absolute;
            right: 35px; /* ä½äºå±•å¼€æŒ‡ç¤ºå™¨å·¦ä¾§ */
            top: 50%;
            transform: translateY(-50%);
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: #f0f9ff;
            border: 2px solid #0ea5e9;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 10;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .checklist-indicator:hover {
            background: #0ea5e9;
            border-color: #0ea5e9;
            color: white;
            transform: translateY(-50%) scale(1.1);
        }

        /* æ£€æŸ¥æ¸…å•å¼¹å‡ºæ¡† */
        .checklist-popup {
            position: absolute;
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            padding: 12px 16px;
            min-width: 200px;
            max-width: 400px;
            font-size: 13px;
            line-height: 1.5;
        }

        .checklist-popup .checklist-title {
            font-weight: 600;
            color: #2d3748;
            margin-bottom: 8px;
            padding-bottom: 6px;
            border-bottom: 1px solid #e2e8f0;
        }

        .checklist-popup .checklist-item {
            margin: 4px 0;
            color: #4a5568;
            display: flex;
            align-items: flex-start;
        }

        .checklist-popup .checklist-item::before {
            content: "â€¢";
            color: #0ea5e9;
            font-weight: bold;
            margin-right: 6px;
            margin-top: 2px;
        }

        .checklist-popup .checklist-item.level-1 {
            margin-left: 12px;
            font-size: 12px;
            color: #718096;
        }

        .checklist-popup .close-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            background: none;
            border: none;
            font-size: 16px;
            color: #a0aec0;
            cursor: pointer;
            padding: 2px;
            line-height: 1;
        }

        .checklist-popup .close-btn:hover {
            color: #4a5568;
        }

        /* è¿æ¥çº¿å®¹å™¨ */
        .connections-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5; /* é™ä½åŸºç¡€å±‚çº§ï¼Œè®©å¡ç‰‡å¯ä»¥æ˜¾ç¤ºåœ¨è¿çº¿ä¸Šæ–¹ */
            opacity: 0; /* åˆå§‹éšè—ï¼Œç­‰ç”¨æˆ·äº¤äº’åå†æ˜¾ç¤º */
            transition: opacity 0.3s ease;
            transform-origin: 0 0; /* ç¡®ä¿å˜æ¢åŸç‚¹ä¸å®¹å™¨ä¸€è‡´ */
            overflow: visible; /* ç¡®ä¿è¿æ¥çº¿ä¸ä¼šè¢«è£å‰ª */
        }

        .connections-svg.visible {
            opacity: 1; /* ç”¨æˆ·äº¤äº’åæ˜¾ç¤º */
        }

        /* æ‹–åŠ¨æ—¶éšè—è¿æ¥çº¿ */
        .connections-svg.dragging {
            opacity: 0;
            transition: opacity 0.1s ease;
        }

        /* å¯è§çš„è¿æ¥çº¿æ ·å¼ */
        .connection-line {
            fill: none;
            stroke: #e2e8f0;
            stroke-width: 2;
            opacity: 0; /* é»˜è®¤éšè—ï¼Œåªæœ‰visibleæˆ–activeæ—¶æ‰æ˜¾ç¤º */
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .connection-line.visible {
            opacity: 0.8;
            stroke: #cbd5e0;
            stroke-width: 3;
        }

        /* å½“å‰æ´»è·ƒè·¯å¾„æ ·å¼ - äº¤äº’å±‚ */
        .connection-line.active {
            opacity: 1;
            stroke: #007AFF;
            stroke-width: 4;
            filter: drop-shadow(0 2px 8px rgba(0, 122, 255, 0.3));
            animation: pathPulse 2s ease-in-out infinite;
            z-index: 8;
        }

        /* æ¢ç´¢è·¯å¾„æ ·å¼ - èƒŒæ™¯å±‚ */
        .connection-line.exploration {
            opacity: 0.25;
            stroke: #9CA3AF;
            stroke-width: 1.5;
            stroke-dasharray: 4, 4;
            z-index: 1;
            transition: all 0.3s ease;
        }

        /* æ¢ç´¢è·¯å¾„æ‚¬åœæ•ˆæœ */
        .connection-line.exploration:hover,
        .connection-line.exploration.highlighted {
            opacity: 0.6;
            stroke: #6B7280;
            stroke-width: 3;
            z-index: 5;
            stroke-dasharray: 6, 3;
        }

        /* è§£å†³æ–¹æ¡ˆè·¯å¾„æ ·å¼ - ç»“æœå±‚ï¼ˆæœ€é«˜ä¼˜å…ˆçº§ï¼‰ */
        .connection-line.solution {
            opacity: 1;
            stroke: #F59E0B;
            stroke-width: 5;
            filter: drop-shadow(0 3px 12px rgba(245, 158, 11, 0.4));
            animation: solutionPulse 3s ease-in-out infinite;
            z-index: 10;
        }

        /* æœç´¢è·¯å¾„æ ·å¼ - æœç´¢ç»“æœå±‚ï¼ˆæœ€é«˜ä¼˜å…ˆçº§ï¼‰ */
        .connection-line.search-path {
            opacity: 1;
            stroke: #0EA5E9;
            stroke-width: 6;
            filter: drop-shadow(0 4px 16px rgba(14, 165, 233, 0.5));
            animation: searchPathPulse 2.5s ease-in-out infinite;
            z-index: 12;
        }

        /* è·¯å¾„è„‰åŠ¨åŠ¨ç”» */
        @keyframes pathPulse {
            0%, 100% {
                stroke-width: 4;
            opacity: 1;
            }
            50% {
                stroke-width: 5;
                opacity: 0.8;
            }
        }

        /* è§£å†³æ–¹æ¡ˆè·¯å¾„è„‰åŠ¨åŠ¨ç”» */
        @keyframes solutionPulse {
            0%, 100% {
                stroke-width: 5;
                opacity: 1;
            }
            50% {
                stroke-width: 6;
                opacity: 0.9;
                filter: drop-shadow(0 4px 16px rgba(245, 158, 11, 0.6));
            }
        }

        /* æœç´¢è·¯å¾„è„‰åŠ¨åŠ¨ç”» */
        @keyframes searchPathPulse {
            0%, 100% {
                stroke-width: 6;
                opacity: 1;
            }
            50% {
                stroke-width: 8;
                opacity: 0.8;
                filter: drop-shadow(0 6px 20px rgba(14, 165, 233, 0.7));
            }
        }


        /* éšè—çŠ¶æ€ */
        .card.hidden {
            opacity: 0;
            transform: scale(0.8) translateY(10px);
            pointer-events: none;
        }

        /* é¡µé¢æ ‡é¢˜ï¼ˆéšè—ä½†ä¿æŒè¯­ä¹‰æ€§ï¼‰ */
        .page-title {
            position: absolute;
            left: -9999px;
            font-size: 1px;
        }

        /* ä¸“æ³¨æ¨¡å¼ï¼šç§»é™¤æ‰€æœ‰ä¸å¿…è¦çš„è§†è§‰å¹²æ‰° */
        :focus {
            outline: none;
        }

        ::selection {
            background-color: rgba(0, 122, 255, 0.2);
        }

        /* æ§åˆ¶é¢æ¿ */
        .controls {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }

        /* æœç´¢å®¹å™¨ */
        .search-container {
            position: relative;
            display: flex;
            align-items: center;
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            transition: all 0.2s ease;
        }

        .search-container:focus-within {
            border-color: #007AFF;
            box-shadow: 0 4px 8px rgba(0, 122, 255, 0.15);
        }

        /* æœç´¢è¾“å…¥æ¡† */
        .search-input {
            padding: 8px 12px;
            border: none;
            outline: none;
            font-size: 12px;
            font-weight: 500;
            color: #4a5568;
            background: transparent;
            width: 180px;
            border-radius: 8px;
        }

        .search-input::placeholder {
            color: #a0aec0;
        }

        /* æœç´¢æ¸…é™¤æŒ‰é’® */
        .search-clear-btn {
            position: absolute;
            right: 4px;
            padding: 4px 6px;
            border: none;
            background: none;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            color: #a0aec0;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .search-clear-btn:hover {
            background: #f7fafc;
            color: #4a5568;
        }

        /* æœç´¢å»ºè®®ä¸‹æ‹‰æ¡† */
        .search-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #e2e8f0;
            border-top: none;
            border-radius: 0 0 8px 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 1001;
            max-height: 300px;
            overflow-y: auto;
            font-size: 12px;
        }

        .suggestions-header {
            padding: 8px 12px;
            background: #f8fafc;
            border-bottom: 1px solid #e2e8f0;
            font-weight: 600;
            color: #4a5568;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .suggestions-list {
            max-height: 250px;
            overflow-y: auto;
        }

        .suggestion-item {
            padding: 10px 12px;
            cursor: pointer;
            border-bottom: 1px solid #f1f5f9;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: space-between;
            user-select: none;
            -webkit-user-select: none;
        }

        .suggestion-item:last-child {
            border-bottom: none;
        }

        .suggestion-item:hover,
        .suggestion-item.highlighted {
            background: #f0f9ff;
            border-left: 3px solid #0ea5e9;
        }

        .suggestion-content {
            flex: 1;
            min-width: 0;
        }

        .suggestion-title {
            font-weight: 500;
            color: #2d3748;
            margin-bottom: 2px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .suggestion-path {
            font-size: 10px;
            color: #718096;
            opacity: 0.8;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .suggestion-match {
            background: #fef3c7;
            color: #92400e;
            font-weight: 600;
            padding: 0 2px;
            border-radius: 2px;
        }

        .suggestion-icon {
            margin-left: 8px;
            color: #94a3b8;
            font-size: 14px;
            opacity: 0.6;
        }

        .suggestion-item:hover .suggestion-icon {
            color: #0ea5e9;
            opacity: 1;
        }

        /* ç‰ˆæƒä¿¡æ¯ - ç®€çº¦å·¦ä¸Šè§’ */
        .copyright-badge {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 999;
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 8px 12px;
            font-size: 11px;
            color: #666;
            border: 1px solid rgba(0, 0, 0, 0.05);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
            transition: all 0.3s ease;
            cursor: pointer;
            user-select: none;
        }

        .copyright-badge:hover {
            background: rgba(255, 255, 255, 0.95);
            color: #333;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .copyright-badge .author {
            font-weight: 500;
            color: #007AFF;
        }

        .copyright-badge .social {
            display: none;
            margin-top: 4px;
            font-size: 10px;
            color: #888;
            line-height: 1.3;
        }

        .copyright-badge:hover .social {
            display: block;
        }

        .control-btn {
            padding: 8px 16px;
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            color: #4a5568;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .control-btn:hover {
            background: #f7fafc;
            border-color: #007AFF;
            color: #007AFF;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        /* å¤åˆ¶æŒ‰é’®ç‰¹æ®Šæ ·å¼ */
        #copyBtn {
            background: linear-gradient(135deg, #10B981, #059669);
            color: white;
            border: none;
            font-weight: 600;
        }

        #copyBtn:hover {
            background: linear-gradient(135deg, #059669, #047857);
            color: white;
            border: none;
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(16, 185, 129, 0.3);
        }

        /* å¤åˆ¶æˆåŠŸåŠ¨ç”» */
        #copyBtn.copied {
            background: linear-gradient(135deg, #F59E0B, #D97706);
            animation: copySuccess 0.6s ease;
        }

        @keyframes copySuccess {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        /* å“åº”å¼è®¾è®¡ */
        @media (max-width: 768px) {
            .mindmap-container {
                padding: 20px;
            }
            
            .column {
                min-width: 200px;
                margin-right: 20px;
            }
            
            .card {
                max-width: 200px;
            }
            
            .card-content {
                padding: 12px 28px 12px 16px; /* ç§»åŠ¨ç«¯å‡å°‘å³ä¾§å†…è¾¹è· */
                font-size: 13px;
            }
            
            .card.root-card .card-content {
                font-size: 16px;
                padding: 18px 36px 18px 20px; /* ç§»åŠ¨ç«¯æ ¹èŠ‚ç‚¹å‡å°‘å³ä¾§å†…è¾¹è· */
            }

            /* ç§»åŠ¨ç«¯æ§åˆ¶é¢æ¿ä¼˜åŒ– */
            .controls {
                top: 10px;
                right: 10px;
                flex-wrap: wrap;
                max-width: 300px;
                flex-direction: column;
                align-items: flex-end;
                gap: 8px;
            }

            /* ç§»åŠ¨ç«¯æœç´¢æ¡†ä¼˜åŒ– */
            .search-container {
                width: 100%;
                max-width: 200px;
            }

            .search-input {
                width: 140px;
                font-size: 11px;
                padding: 6px 10px;
            }

            /* ç§»åŠ¨ç«¯æœç´¢å»ºè®®ä¼˜åŒ– */
            .search-suggestions {
                font-size: 11px;
                max-height: 200px;
            }

            .suggestion-item {
                padding: 8px 10px;
            }

            .suggestion-title {
                font-size: 11px;
            }

            .suggestion-path {
                font-size: 9px;
            }

            .control-btn {
                padding: 10px 12px;
                font-size: 11px;
                min-height: 44px; /* iOSæ¨èçš„æœ€å°è§¦æ‘¸ç›®æ ‡ */
                min-width: 60px;
                display: flex;
                align-items: center;
                justify-content: center;
                touch-action: manipulation;
            }

            /* ç§»åŠ¨ç«¯å±•å¼€æŒ‡ç¤ºå™¨ä¼˜åŒ– */
            .expand-indicator {
                width: 26px;
                height: 26px;
                font-size: 11px;
                right: 6px;
            }

            /* ç§»åŠ¨ç«¯æ£€æŸ¥æ¸…å•æŒ‡ç¤ºå™¨ä¼˜åŒ– */
            .checklist-indicator {
                width: 26px;
                height: 26px;
                font-size: 13px;
                right: 38px;
            }

            /* ç§»åŠ¨ç«¯æ£€æŸ¥æ¸…å•å¼¹å‡ºæ¡†ä¼˜åŒ– */
            .checklist-popup {
                max-width: 280px;
                font-size: 12px;
            }

            /* ç§»åŠ¨ç«¯ç‰ˆæƒä¿¡æ¯ä¼˜åŒ– */
            .copyright-badge {
                top: 10px;
                left: 10px;
                padding: 6px 10px;
                font-size: 10px;
                border-radius: 10px;
            }

            .copyright-badge .social {
                font-size: 9px;
            }
        }
    </style>
</head>
<body>
    <div class="slate">
        <h1 class="page-title">å›¾å½¢æ¨ç†æ€ç»´å¯¼å›¾</h1>
        
        <!-- ç‰ˆæƒä¿¡æ¯ -->
        <div class="copyright-badge">
            <span class="author">Â© panda</span>
            <div class="social">
                å°çº¢ä¹¦: å…¬è€ƒå°é¥­å›¢<br>
                å¾®ä¿¡ï¼šFeynmanda
            </div>
        </div>
        
        <!-- æ§åˆ¶é¢æ¿ -->
        <div class="controls">
            <!-- æœç´¢æ¡† -->
            <div class="search-container">
                <input type="text" id="searchInput" class="search-input" placeholder="æœç´¢èŠ‚ç‚¹å†…å®¹..." autocomplete="off" />
                <button class="search-clear-btn" onclick="clearSearch()" id="searchClearBtn" style="display: none;">Ã—</button>
                <!-- æœç´¢å»ºè®®ä¸‹æ‹‰æ¡† -->
                <div class="search-suggestions" id="searchSuggestions" style="display: none;">
                    <div class="suggestions-header">æœç´¢ç»“æœ</div>
                    <div class="suggestions-list" id="suggestionsList">
                        <!-- åŠ¨æ€ç”Ÿæˆçš„å»ºè®®é¡¹ -->
                    </div>
                </div>
            </div>
            <button class="control-btn" onclick="resetMindmap()">é‡ç½® (F5)</button>
            <button class="control-btn" onclick="centerView()">å±…ä¸­</button>
            <button class="control-btn path-action-btn" onclick="tryAnotherPath()" id="tryAnotherBtn">æ¢è·¯</button>
            <button class="control-btn path-action-btn" onclick="confirmSolution()" id="confirmBtn">ç¡®è®¤è§£æ³•</button>
            <button class="control-btn path-action-btn" onclick="copySolutionPath()" id="copyBtn" style="display: none;">ğŸ“‹ å¤åˆ¶è§£æ³•</button>
        </div>

        <!-- æ€ç»´å¯¼å›¾ç”»å¸ƒ -->
        <div class="mindmap-canvas" id="mindmapCanvas">
            <svg class="connections-svg" id="connectionSvg">
                <defs>
                    <!-- æ¿€æ´»è·¯å¾„æ¸å˜ -->
                    <linearGradient id="activeGradient" x1="0%" y1="0%" x2="100%" y2="0%">
                        <stop offset="0%" style="stop-color:#007AFF;stop-opacity:1" />
                        <stop offset="50%" style="stop-color:#0056CC;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#007AFF;stop-opacity:1" />
                    </linearGradient>
                    
                    <!-- éæ¿€æ´»è·¯å¾„æ¸å˜ -->
                    <linearGradient id="inactiveGradient" x1="0%" y1="0%" x2="100%" y2="0%">
                        <stop offset="0%" style="stop-color:#cbd5e0;stop-opacity:0.6" />
                        <stop offset="100%" style="stop-color:#e2e8f0;stop-opacity:0.6" />
                    </linearGradient>
                    
                    <!-- é»˜è®¤è¿æ¥çº¿æ¸å˜ -->
                    <linearGradient id="connectionGradient" x1="0%" y1="0%" x2="100%" y2="0%">
                        <stop offset="0%" style="stop-color:#f1f5f9;stop-opacity:0.8" />
                        <stop offset="100%" style="stop-color:#e2e8f0;stop-opacity:0.8" />
                    </linearGradient>
                    
                    <!-- ç®­å¤´æ ‡è®° -->
                    <marker id="arrowhead" markerWidth="10" markerHeight="7" 
                            refX="9" refY="3.5" orient="auto" markerUnits="strokeWidth">
                        <polygon points="0 0, 10 3.5, 0 7" fill="#007AFF" />
                    </marker>
                    
                    <!-- æ¿€æ´»ç®­å¤´ -->
                    <marker id="activeArrow" markerWidth="12" markerHeight="8" 
                            refX="11" refY="4" orient="auto" markerUnits="strokeWidth">
                        <polygon points="0 0, 12 4, 0 8" fill="url(#activeGradient)" 
                                 filter="drop-shadow(0 2px 4px rgba(0, 122, 255, 0.3))" />
                    </marker>
                </defs>
            </svg>
            <div class="mindmap-container" id="mindmapContainer">
                <!-- æ€ç»´å¯¼å›¾èŠ‚ç‚¹å°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
            </div>
        </div>
    </div>

    <script>
        // æ€ç»´å¯¼å›¾æ•°æ®å·²å®šä¹‰åœ¨æ–‡ä»¶å¼€å¤´

        // Markdownè§£æå™¨ï¼šå°†markdownæ ¼å¼è½¬æ¢ä¸ºåµŒå¥—å¯¹è±¡
        function parseMarkdownToMindmap(markdown) {
            const lines = markdown.split('\n').filter(line => line.trim());
            const root = { id: 'root', text: '', children: [], checklist: [] };
            const stack = [{ node: root, level: -1 }];
            let idCounter = 0;
            
            lines.forEach(line => {
                const trimmedLine = line.trim();
                
                // æ£€æŸ¥æ˜¯å¦æ˜¯æ£€æŸ¥æ¸…å•é¡¹ï¼ˆä»¥ * å¼€å¤´ï¼‰
                const checklistMatch = line.match(/^(\s*)\*\s*(.+)$/);
                if (checklistMatch) {
                    const indentStr = checklistMatch[1];
                    const text = checklistMatch[2].trim();
                    const level = indentStr.length / 2;
                    
                    // æ‰¾åˆ°å¯¹åº”çš„çˆ¶èŠ‚ç‚¹ï¼Œå°†æ£€æŸ¥æ¸…å•é¡¹æ·»åŠ åˆ°çˆ¶èŠ‚ç‚¹
                    const targetLevel = level - 1; // æ£€æŸ¥æ¸…å•é¡¹çš„çˆ¶èŠ‚ç‚¹å±‚çº§
                    while (stack.length > 0 && stack[stack.length - 1].level > targetLevel) {
                        stack.pop();
                    }
                    
                    if (stack.length > 0) {
                        const parentNode = stack[stack.length - 1].node;
                        if (!parentNode.checklist) {
                            parentNode.checklist = [];
                        }
                        parentNode.checklist.push({
                            text: text,
                            level: level - targetLevel - 1 // ç›¸å¯¹äºçˆ¶èŠ‚ç‚¹çš„å±‚çº§
                        });
                    }
                    return;
                }
                
                // å¤„ç†æ™®é€šçš„æ— åºåˆ—è¡¨é¡¹ï¼ˆèŠ‚ç‚¹ï¼‰
                const match = line.match(/^(\s*)-\s*(.+)$/);
                if (!match) return;
                
                const indentStr = match[1];
                const text = match[2].trim();
                const level = indentStr.length / 2; // æ¯2ä¸ªç©ºæ ¼ä¸ºä¸€çº§
                
                // ç”Ÿæˆå”¯ä¸€ID
                const id = text === 'å›¾å½¢æ¨ç†æ€è€ƒ' ? 'root' : `node_${++idCounter}`;
                
                const newNode = {
                    id: id,
                    text: text,
                    children: [],
                    checklist: []
                };
                
                // å¦‚æœæ˜¯æ ¹èŠ‚ç‚¹ï¼Œè®¾ç½®æ–‡æœ¬
                if (level === 0) {
                    root.text = text;
                    root.id = 'root';
                    return;
                }
                
                // æ‰¾åˆ°æ­£ç¡®çš„çˆ¶èŠ‚ç‚¹
                while (stack.length > 0 && stack[stack.length - 1].level >= level) {
                    stack.pop();
                }
                
                if (stack.length > 0) {
                    const parent = stack[stack.length - 1].node;
                    parent.children.push(newNode);
                }
                
                // å°†å½“å‰èŠ‚ç‚¹æ¨å…¥æ ˆ
                stack.push({ node: newNode, level: level });
            });
            
            return root;
        }
        
        // è§£æmarkdownæ•°æ®ä¸ºæ€ç»´å¯¼å›¾ç»“æ„
        const mindmapData = parseMarkdownToMindmap(mindmapMarkdown);

        class GingkoMindmapRenderer {
            constructor() {
                this.container = document.getElementById('mindmapContainer');
                this.svg = document.getElementById('connectionSvg');
                this.canvas = document.getElementById('mindmapCanvas');
                this.currentPath = ['root']; // å½“å‰æ´»è·ƒè·¯å¾„
                this.explorationPaths = []; // å­˜å‚¨æ‰€æœ‰æ¢ç´¢è·¯å¾„
                this.solutionPath = null; // æœ€ç»ˆç¡®å®šçš„è§£é¢˜è·¯å¾„
                this.cards = new Map(); // å­˜å‚¨å¡ç‰‡ä¿¡æ¯
                this.scale = 1;
                this.translateX = 0;
                this.translateY = 0;
                this.pathMode = 'exploring'; // 'exploring' | 'confirmed'
                this.keyboardFocusedCard = null; // å½“å‰é”®ç›˜ç„¦ç‚¹çš„å¡ç‰‡ID
                this.positionUpdatePending = false; // è¿æ¥çº¿ä½ç½®æ›´æ–°é˜²æŠ–æ ‡å¿—
                this.searchResults = []; // æœç´¢ç»“æœèŠ‚ç‚¹IDåˆ—è¡¨
                this.isSearchActive = false; // æ˜¯å¦æ­£åœ¨è¿›è¡Œæœç´¢
                this.isFocusMode = false; // æ˜¯å¦å¤„äºèšç„¦æ¨¡å¼ï¼ˆåªæ˜¾ç¤ºé€‰ä¸­çš„èŠ‚ç‚¹ï¼‰
                this.currentSuggestionIndex = -1; // å½“å‰é€‰ä¸­çš„å»ºè®®é¡¹ç´¢å¼•
                this.searchSuggestions = []; // æœç´¢å»ºè®®åˆ—è¡¨
                
                this.setupCanvas();
                this.setupKeyboardNavigation();
                this.setupSearchFunctionality();
                this.render();
            }

            setupCanvas() {
                let isDragging = false;
                let startX, startY, startTranslateX, startTranslateY;
                let lastTouchDistance = 0;
                let initialScale = 1;
                let touchStartTime = 0;
                let hasMoved = false;

                // è·å–äº‹ä»¶åæ ‡çš„ç»Ÿä¸€å‡½æ•°
                const getEventCoords = (e) => {
                    if (e.touches && e.touches.length > 0) {
                        return { x: e.touches[0].clientX, y: e.touches[0].clientY };
                    }
                    return { x: e.clientX, y: e.clientY };
                };

                // æ£€æŸ¥æ˜¯å¦å¯ä»¥å¼€å§‹æ‹–åŠ¨ï¼ˆé¿å…åœ¨å¡ç‰‡ä¸Šæ‹–åŠ¨ï¼‰
                const canStartDrag = (target) => {
                    return target === this.canvas || 
                           target === this.svg || 
                           target === this.container ||
                           target.classList.contains('mindmap-container') ||
                           target.classList.contains('mindmap-canvas') ||
                           target.classList.contains('connections-svg');
                };

                // å¼€å§‹æ‹–åŠ¨çš„ç»Ÿä¸€å¤„ç†å‡½æ•°
                const startDrag = (e) => {
                    if (canStartDrag(e.target)) {
                        isDragging = true;
                        hasMoved = false;
                        touchStartTime = Date.now();
                        const coords = getEventCoords(e);
                        startX = coords.x;
                        startY = coords.y;
                        startTranslateX = this.translateX;
                        startTranslateY = this.translateY;
                        
                        // å¯¹äºè§¦æ‘¸äº‹ä»¶ï¼Œå»¶è¿Ÿæ·»åŠ æ‹–åŠ¨çŠ¶æ€ï¼Œä»¥å…å½±å“å¡ç‰‡ç‚¹å‡»
                        if (e.type.startsWith('touch')) {
                            setTimeout(() => {
                                if (isDragging && hasMoved) {
                                    this.canvas.classList.add('dragging');
                                    this.svg.classList.add('dragging');
                                }
                            }, 100);
                        } else {
                            this.canvas.classList.add('dragging');
                            this.svg.classList.add('dragging');
                        }
                    }
                };

                // æ‹–åŠ¨è¿‡ç¨‹çš„ç»Ÿä¸€å¤„ç†å‡½æ•°
                const doDrag = (e) => {
                    if (isDragging) {
                        const coords = getEventCoords(e);
                        const deltaX = coords.x - startX;
                        const deltaY = coords.y - startY;
                        
                        // æ£€æµ‹æ˜¯å¦çœŸçš„åœ¨ç§»åŠ¨ï¼ˆé˜ˆå€¼ä¸º5åƒç´ ï¼‰
                        if (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5) {
                            hasMoved = true;
                            e.preventDefault();
                            
                            this.translateX = startTranslateX + deltaX;
                            this.translateY = startTranslateY + deltaY;
                            this.updateTransform();
                            
                            // å¦‚æœè¿˜æ²¡æœ‰æ·»åŠ æ‹–åŠ¨çŠ¶æ€ï¼Œç°åœ¨æ·»åŠ 
                            if (!this.canvas.classList.contains('dragging')) {
                                this.canvas.classList.add('dragging');
                                this.svg.classList.add('dragging');
                            }
                        }
                    }
                };

                // ç»“æŸæ‹–åŠ¨çš„ç»Ÿä¸€å¤„ç†å‡½æ•°
                const endDrag = () => {
                    if (isDragging) {
                        isDragging = false;
                        this.canvas.classList.remove('dragging');
                        this.svg.classList.remove('dragging');
                        
                        if (hasMoved) {
                            setTimeout(() => {
                                this.updateAllConnectionPositions();
                            }, 50);
                        }
                        
                        hasMoved = false;
                    }
                };

                // é¼ æ ‡äº‹ä»¶
                this.canvas.addEventListener('mousedown', startDrag);
                document.addEventListener('mousemove', doDrag);
                document.addEventListener('mouseup', endDrag);

                // è§¦æ‘¸äº‹ä»¶ - æ”¹è¿›ç‰ˆæœ¬ï¼Œç»‘å®šåˆ°documentä»¥ç¡®ä¿å…¨å±€æ•è·
                document.addEventListener('touchstart', (e) => {
                    // æ£€æŸ¥è§¦æ‘¸æ˜¯å¦åœ¨ç”»å¸ƒåŒºåŸŸå†…
                    const canvasRect = this.canvas.getBoundingClientRect();
                    const touch = e.touches[0];
                    const isInCanvas = touch.clientX >= canvasRect.left && 
                                     touch.clientX <= canvasRect.right && 
                                     touch.clientY >= canvasRect.top && 
                                     touch.clientY <= canvasRect.bottom;
                    
                    if (!isInCanvas) return;
                    
                    if (e.touches.length === 1) {
                        // å•æŒ‡è§¦æ‘¸ï¼šå¯èƒ½æ˜¯æ‹–åŠ¨æˆ–ç‚¹å‡»
                        startDrag(e);
                    } else if (e.touches.length === 2) {
                        // åŒæŒ‡è§¦æ‘¸ï¼šå‡†å¤‡ç¼©æ”¾
                        endDrag(); // å…ˆç»“æŸå¯èƒ½çš„æ‹–åŠ¨
                        const touch1 = e.touches[0];
                        const touch2 = e.touches[1];
                        lastTouchDistance = Math.sqrt(
                            Math.pow(touch2.clientX - touch1.clientX, 2) +
                            Math.pow(touch2.clientY - touch1.clientY, 2)
                        );
                        initialScale = this.scale;
                        this.svg.classList.add('dragging');
                    }
                }, { passive: false });

                document.addEventListener('touchmove', (e) => {
                    if (e.touches.length === 1) {
                        // å•æŒ‡ç§»åŠ¨ï¼šæ‹–åŠ¨
                        doDrag(e);
                    } else if (e.touches.length === 2) {
                        // åŒæŒ‡ç§»åŠ¨ï¼šç¼©æ”¾
                        e.preventDefault();
                        const touch1 = e.touches[0];
                        const touch2 = e.touches[1];
                        const currentDistance = Math.sqrt(
                            Math.pow(touch2.clientX - touch1.clientX, 2) +
                            Math.pow(touch2.clientY - touch1.clientY, 2)
                        );
                        
                        if (lastTouchDistance > 0) {
                            const scaleChange = currentDistance / lastTouchDistance;
                            this.scale = initialScale * scaleChange;
                            this.scale = Math.max(0.5, Math.min(3, this.scale));
                            this.updateTransform();
                        }
                    }
                }, { passive: false });

                document.addEventListener('touchend', (e) => {
                    if (e.touches.length === 0) {
                        // æ‰€æœ‰æ‰‹æŒ‡éƒ½ç¦»å¼€äº†
                        endDrag();
                        lastTouchDistance = 0;
                        clearTimeout(this.scaleTimeout);
                        this.scaleTimeout = setTimeout(() => {
                            this.svg.classList.remove('dragging');
                            this.updateAllConnectionPositions();
                        }, 100);
                    } else if (e.touches.length === 1) {
                        // ä»åŒæŒ‡å˜æˆå•æŒ‡
                        lastTouchDistance = 0;
                        clearTimeout(this.scaleTimeout);
                        this.scaleTimeout = setTimeout(() => {
                            this.svg.classList.remove('dragging');
                            this.updateAllConnectionPositions();
                        }, 100);
                        // é‡æ–°å¼€å§‹å•æŒ‡æ‹–åŠ¨
                        setTimeout(() => {
                            if (e.touches.length === 1) {
                                startDrag(e);
                            }
                        }, 10);
                    }
                }, { passive: false });

                // é˜»æ­¢è§¦æ‘¸æ—¶çš„é»˜è®¤è¡Œä¸ºï¼ˆå¦‚é¡µé¢æ»šåŠ¨ï¼‰
                document.addEventListener('touchcancel', endDrag, { passive: false });

                // é¼ æ ‡æ»šè½®ç¼©æ”¾æ”¯æŒ
                this.canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const delta = e.deltaY > 0 ? 0.9 : 1.1;
                    this.scale *= delta;
                    this.scale = Math.max(0.5, Math.min(3, this.scale));
                    
                    // ç¼©æ”¾æ—¶çŸ­æš‚éšè—è¿æ¥çº¿
                    this.svg.classList.add('dragging');
                    
                    this.updateTransform();
                    
                    // ç¼©æ”¾ç»“æŸåæ¢å¤è¿æ¥çº¿
                    clearTimeout(this.scaleTimeout);
                    this.scaleTimeout = setTimeout(() => {
                        this.svg.classList.remove('dragging');
                        this.updateAllConnectionPositions();
                    }, 100);
                }, { passive: false });
            }

            setupKeyboardNavigation() {
                document.addEventListener('keydown', (e) => {
                    // å¦‚æœå·²ç¡®è®¤è§£å†³æ–¹æ¡ˆï¼Œä¸å…è®¸é”®ç›˜å¯¼èˆª
                    if (this.pathMode === 'confirmed') return;
                    
                    switch(e.key) {
                        case 'ArrowUp':
                            e.preventDefault();
                            this.navigateToSibling('up');
                            break;
                        case 'ArrowDown':
                            e.preventDefault();
                            this.navigateToSibling('down');
                            break;
                        case 'ArrowLeft':
                            e.preventDefault();
                            this.navigateToParent();
                            break;
                        case 'ArrowRight':
                            e.preventDefault();
                            this.navigateToChild();
                            break;
                        case 'Enter':
                            e.preventDefault();
                            this.selectFocusedCard();
                            break;
                        case 'Escape':
                            e.preventDefault();
                            this.clearKeyboardFocus();
                            break;
                    }
                });

                // é¼ æ ‡ç‚¹å‡»æ—¶è®¾ç½®é”®ç›˜ç„¦ç‚¹ï¼ˆä½†ä¸æ¸…é™¤ï¼Œè®©é”®ç›˜å¯¼èˆªæ›´è¿è´¯ï¼‰
                this.canvas.addEventListener('click', (e) => {
                    const clickedCard = e.target.closest('.card');
                    if (clickedCard && !clickedCard.classList.contains('hidden')) {
                        this.setKeyboardFocus(clickedCard.dataset.nodeId);
                    }
                });
            }

            setupSearchFunctionality() {
                const searchInput = document.getElementById('searchInput');
                const searchClearBtn = document.getElementById('searchClearBtn');
                const searchSuggestions = document.getElementById('searchSuggestions');
                
                if (!searchInput || !searchClearBtn || !searchSuggestions) return;

                // æœç´¢è¾“å…¥äº‹ä»¶ - å®æ—¶æœç´¢
                searchInput.addEventListener('input', (e) => {
                    const query = e.target.value.trim();
                    if (query.length > 0) {
                        this.performSearchWithSuggestions(query);
                        searchClearBtn.style.display = 'block';
                    } else {
                        // ç«‹å³æ¸…é™¤æœç´¢çŠ¶æ€å’Œæ ·å¼
                        this.isSearchActive = false;
                        this.searchResults = [];
                        this.clearSearchStyles();
                        this.hideSuggestions();
                        this.updateDisplay();
                        searchClearBtn.style.display = 'none';
                    }
                });

                // æœç´¢æ¡†å¿«æ·é”®
                searchInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        this.clearSearch();
                        searchInput.blur();
                    } else if (e.key === 'ArrowDown') {
                        e.preventDefault();
                        this.navigateSuggestions('down');
                    } else if (e.key === 'ArrowUp') {
                        e.preventDefault();
                        this.navigateSuggestions('up');
                    } else if (e.key === 'Enter') {
                        e.preventDefault();
                        this.selectCurrentSuggestion();
                    }
                });

                // ç‚¹å‡»ç©ºç™½åŒºåŸŸéšè—å»ºè®®æ¡†
                document.addEventListener('click', (e) => {
                    // æ£€æŸ¥ç‚¹å‡»æ˜¯å¦åœ¨æœç´¢å®¹å™¨å¤–
                    const searchContainer = document.querySelector('.search-container');
                    if (searchContainer && !searchContainer.contains(e.target)) {
                        this.hideSuggestions();
                    }
                });

                // æœç´¢æ¡†è·å¾—ç„¦ç‚¹æ—¶æ˜¾ç¤ºå»ºè®®æ¡†ï¼ˆå¦‚æœæœ‰æœç´¢ç»“æœï¼‰
                searchInput.addEventListener('focus', () => {
                    if (this.searchSuggestions.length > 0) {
                        this.showSuggestions();
                    }
                });
            }

            updateTransform() {
                const transform = `translate(${this.translateX}px, ${this.translateY}px) scale(${this.scale})`;
                this.container.style.transform = transform;
                // SVGä¹Ÿéœ€è¦è·Ÿéšç›¸åŒçš„å˜æ¢ï¼Œè¿™æ ·è¿æ¥çº¿åæ ‡ç³»ç»Ÿå°±èƒ½ä¸å¡ç‰‡ä¿æŒä¸€è‡´
                this.svg.style.transform = transform;
            }

            render() {
                console.log('=== Gingkoæ¸²æŸ“å¼€å§‹ ===');
                this.container.innerHTML = '';
                this.svg.innerHTML = '';
                this.cards.clear();
                this.currentPath = ['root'];
                
                // åˆ›å»ºGingkoé£æ ¼çš„åˆ—å¸ƒå±€
                this.createGingkoLayout();
                
                // å…ˆå±…ä¸­ç”»å¸ƒï¼Œé¿å…é¦–æ¬¡ç»˜åˆ¶ä½ç½®åå·®
                this.centerView();
                
                // æ›´æ–°æ˜¾ç¤ºçŠ¶æ€ï¼ˆåœ¨å±…ä¸­ä¹‹åï¼‰
                this.updateDisplay();
                
                // é¦–æ¬¡æ¸²æŸ“ä¸æ˜¾ç¤ºè¿æ¥çº¿ï¼Œç­‰ç”¨æˆ·äº¤äº’åå†æ˜¾ç¤º
                this.svg.classList.remove('visible');
            }

            createGingkoLayout() {
                // é€’å½’åˆ›å»ºæ‰€æœ‰å¡ç‰‡ï¼Œä½¿ç”¨ç»å¯¹å®šä½
                this.createCardsRecursively(mindmapData, 0, 100, 100);
            }

            createCardsRecursively(nodeData, level, x, y) {
                // åˆ›å»ºå½“å‰å¡ç‰‡
                this.createCard(nodeData, level, x, y);
                
                // é€’å½’åˆ›å»ºå­å¡ç‰‡
                if (nodeData.children && nodeData.children.length > 0) {
                    const childX = x + 300; // æ¯åˆ—é—´è·300px
                    const childSpacing = 80; // æ¯ä¸ªå­å¡ç‰‡é—´è·80px
                    const totalHeight = (nodeData.children.length - 1) * childSpacing;
                    const startY = y - totalHeight / 2;
                    
                    nodeData.children.forEach((child, index) => {
                        const childY = startY + index * childSpacing;
                        this.createCardsRecursively(child, level + 1, childX, childY);
                    });
                }
            }

            createCard(nodeData, level, x, y) {
                const card = document.createElement('div');
                card.className = `card ${level === 0 ? 'root-card' : level === 1 ? 'branch-card' : 'leaf-card'}`;
                card.dataset.nodeId = nodeData.id;
                card.dataset.level = level;
                
                // è®¾ç½®ç»å¯¹ä½ç½®
                card.style.left = x + 'px';
                card.style.top = y + 'px';
                
                // é»˜è®¤éšè—éæ ¹èŠ‚ç‚¹
                if (level > 0) {
                    card.classList.add('hidden');
                }

                const content = document.createElement('div');
                content.className = 'card-content';
                content.textContent = nodeData.text;

                // æ·»åŠ å­èŠ‚ç‚¹æ•°é‡æŒ‡ç¤ºå™¨
                if (nodeData.children && nodeData.children.length > 0) {
                    const indicator = document.createElement('div');
                    indicator.className = 'expand-indicator';
                    indicator.textContent = nodeData.children.length;
                    card.appendChild(indicator);
                }
                
                // æ·»åŠ æ£€æŸ¥æ¸…å•æŒ‡ç¤ºå™¨
                if (nodeData.checklist && nodeData.checklist.length > 0) {
                    const checklistIndicator = document.createElement('div');
                    checklistIndicator.className = 'checklist-indicator';
                    checklistIndicator.innerHTML = 'ğŸ“‹';
                    checklistIndicator.title = 'ç‚¹å‡»æŸ¥çœ‹æ£€æŸ¥æ¸…å•';
                    card.appendChild(checklistIndicator);
                    
                    // æ£€æŸ¥æ¸…å•ç‚¹å‡»äº‹ä»¶
                    checklistIndicator.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.showChecklist(nodeData, checklistIndicator);
                    });
                }

                card.appendChild(content);
                
                // æ·»åŠ ç‚¹å‡»äº‹ä»¶
                card.addEventListener('click', (e) => {
                    e.stopPropagation();
                    console.log('ç‚¹å‡»å¡ç‰‡:', nodeData.id);
                    this.handleCardClick(nodeData.id);
                    // ç‚¹å‡»åè®¾ç½®é”®ç›˜ç„¦ç‚¹ï¼ˆåœ¨handleCardClickä¹‹åï¼Œç¡®ä¿ç•Œé¢å·²æ›´æ–°ï¼‰
                    setTimeout(() => {
                        this.setKeyboardFocus(nodeData.id);
                    }, 50);
                });

                // æ·»åŠ æ‚¬åœäº‹ä»¶ï¼ˆä»…å¯¹æ¢ç´¢è·¯å¾„å¡ç‰‡ï¼‰
                card.addEventListener('mouseenter', (e) => {
                    if (card.classList.contains('exploration')) {
                        this.highlightExplorationPath(nodeData.id);
                    }
                });

                card.addEventListener('mouseleave', (e) => {
                    if (card.classList.contains('exploration')) {
                        this.unhighlightExplorationPath();
                    }
                });

                this.container.appendChild(card);

                // ä¿å­˜å¡ç‰‡ä¿¡æ¯
                this.cards.set(nodeData.id, {
                    element: card,
                    data: nodeData,
                    level: level,
                    x: x,
                    y: y
                });
                
                // åˆ›å»ºè¿æ¥çº¿ï¼ˆå¦‚æœæœ‰çˆ¶èŠ‚ç‚¹ï¼‰
                if (level > 0) {
                    this.createConnection(nodeData, level, x, y);
                }
            }

            createConnection(nodeData, level, x, y) {
                // æ‰¾åˆ°çˆ¶èŠ‚ç‚¹ä½ç½®
                const parentCard = this.findParentCard(nodeData.id);
                if (!parentCard) return;

                const line = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                line.setAttribute('class', 'connection-line');
                line.dataset.from = parentCard.data.id;
                line.dataset.to = nodeData.id;

                this.svg.appendChild(line);
            }

            // æ›´æ–°æ‰€æœ‰è¿æ¥çº¿çš„å®é™…ä½ç½®
            updateAllConnectionPositions() {
                // ä½¿ç”¨requestAnimationFrameä¼˜åŒ–æ€§èƒ½ï¼Œé¿å…æ‹–åŠ¨æ—¶è¿‡åº¦é‡ç»˜
                if (this.positionUpdatePending) return;
                
                this.positionUpdatePending = true;
                requestAnimationFrame(() => {
                const lines = this.svg.querySelectorAll('.connection-line');
                
                lines.forEach((line) => {
                    const fromId = line.dataset.from;
                    const toId = line.dataset.to;
                    
                    const fromCard = this.cards.get(fromId);
                    const toCard = this.cards.get(toId);
                    
                    if (fromCard && toCard && fromCard.element && toCard.element) {
                        // æ£€æŸ¥å…ƒç´ æ˜¯å¦å¯è§
                        if (fromCard.element.classList.contains('hidden') || toCard.element.classList.contains('hidden')) {
                            return;
                        }
                        
                            // ä½¿ç”¨å­˜å‚¨çš„åæ ‡è€Œä¸æ˜¯getBoundingClientRect
                            // å› ä¸ºtransformä¼šå½±å“getBoundingClientRectçš„ç»“æœ
                            const fromX = fromCard.x + 240; // å¡ç‰‡å®½åº¦240pxï¼Œè¿æ¥ç‚¹åœ¨å³è¾¹
                            const fromY = fromCard.y + 40; // è¿æ¥ç‚¹åœ¨å¡ç‰‡ä¸­å¿ƒï¼ˆå¡ç‰‡é«˜åº¦çº¦80pxï¼‰
                            const toX = toCard.x; // è¿æ¥ç‚¹åœ¨å·¦è¾¹
                            const toY = toCard.y + 40; // è¿æ¥ç‚¹åœ¨å¡ç‰‡ä¸­å¿ƒ
                        
                        // åˆ›å»ºè¿æ¥è·¯å¾„
                        const path = this.createSmoothCurvePath(fromX, fromY, toX, toY);
                        line.setAttribute('d', path);
                    }
                    });
                    
                    this.positionUpdatePending = false;
                });
            }

            createSmoothCurvePath(x1, y1, x2, y2) {
                // åˆ›å»ºæµç•…çš„Så‹è´å¡å°”æ›²çº¿
                const dx = x2 - x1;
                const dy = y2 - y1;
                
                // æ§åˆ¶ç‚¹ä½ç½®ï¼Œåˆ›é€ è‡ªç„¶çš„æ›²çº¿
                const cp1x = x1 + dx * 0.6;
                const cp1y = y1;
                const cp2x = x1 + dx * 0.4;
                const cp2y = y2;
                
                return `M ${x1} ${y1} C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${x2} ${y2}`;
            }

            findParentCard(nodeId) {
                // åœ¨æ•°æ®ç»“æ„ä¸­æ‰¾åˆ°çˆ¶èŠ‚ç‚¹
                const findParent = (node, targetId, parent = null) => {
                    if (node.id === targetId) {
                        return parent;
                    }
                    if (node.children) {
                        for (const child of node.children) {
                            const result = findParent(child, targetId, node);
                            if (result) return result;
                        }
                    }
                    return null;
                };
                
                const parentData = findParent(mindmapData, nodeId);
                return parentData ? this.cards.get(parentData.id) : null;
            }

            handleCardClick(nodeId) {
                console.log('=== å¤„ç†å¡ç‰‡ç‚¹å‡» ===');
                console.log('ç‚¹å‡»å¡ç‰‡:', nodeId);
                console.log('å½“å‰è·¯å¾„:', this.currentPath);
                
                // é¦–æ¬¡ç‚¹å‡»æ—¶æ˜¾ç¤ºè¿æ¥çº¿
                if (!this.svg.classList.contains('visible')) {
                    this.svg.classList.add('visible');
                }
                
                // å¦‚æœå·²ç»ç¡®è®¤äº†è§£å†³æ–¹æ¡ˆï¼Œä¸å…è®¸å†ä¿®æ”¹
                if (this.pathMode === 'confirmed') {
                    console.log('è§£å†³æ–¹æ¡ˆå·²ç¡®è®¤ï¼Œæ— æ³•ä¿®æ”¹è·¯å¾„');
                    return;
                }
                
                // æ„å»ºåˆ°ç›®æ ‡èŠ‚ç‚¹çš„è·¯å¾„
                const newPath = this.buildPathToNode(nodeId);
                if (newPath) {
                    this.currentPath = newPath;
                    console.log('æ–°è·¯å¾„:', this.currentPath);
                    this.updateDisplay();
                } else {
                    console.log('æ— æ³•æ‰¾åˆ°èŠ‚ç‚¹è·¯å¾„');
                }
            }

            // æ„å»ºä»æ ¹èŠ‚ç‚¹åˆ°ç›®æ ‡èŠ‚ç‚¹çš„å®Œæ•´è·¯å¾„
            buildPathToNode(targetId) {
                return this.findPathInData(mindmapData, targetId, []);
            }

            // åœ¨æ•°æ®ç»“æ„ä¸­æŸ¥æ‰¾è·¯å¾„
            findPathInData(node, targetId, currentPath) {
                const newPath = [...currentPath, node.id];
                
                if (node.id === targetId) {
                    return newPath;
                }
                
                if (node.children) {
                    for (const child of node.children) {
                        const result = this.findPathInData(child, targetId, newPath);
                        if (result) {
                            return result;
                        }
                    }
                }
                
                return null;
            }

            updateDisplay() {
                console.log('=== æ›´æ–°Gingkoæ˜¾ç¤º ===');
                console.log('å½“å‰è·¯å¾„:', this.currentPath);
                console.log('æ¢ç´¢è·¯å¾„:', this.explorationPaths);
                console.log('è§£å†³æ–¹æ¡ˆè·¯å¾„:', this.solutionPath);
                console.log('æœç´¢æ¿€æ´»:', this.isSearchActive);
                
                // å¦‚æœæœç´¢å¤„äºæ¿€æ´»çŠ¶æ€ï¼Œä½¿ç”¨ç›¸åº”çš„æ˜¾ç¤ºé€»è¾‘
                if (this.isSearchActive) {
                    if (this.isFocusMode) {
                        this.updateDisplayWithFocus();
                    } else {
                        this.updateDisplayWithSearch();
                    }
                    return;
                }
                
                // 1. é‡ç½®æ‰€æœ‰å¡ç‰‡çŠ¶æ€
                this.cards.forEach((cardInfo, nodeId) => {
                    cardInfo.element.classList.add('hidden');
                    cardInfo.element.classList.remove('active', 'exploration', 'solution', 'search-match', 'search-path');
                });

                // 2. æ˜¾ç¤ºå¹¶æ ‡è®°æ‰€æœ‰æ¢ç´¢è·¯å¾„ä¸­çš„å¡ç‰‡
                this.explorationPaths.forEach(path => {
                    path.forEach((nodeId) => {
                    const cardInfo = this.cards.get(nodeId);
                    if (cardInfo) {
                        cardInfo.element.classList.remove('hidden');
                            cardInfo.element.classList.add('exploration');
                        }
                    });
                });

                // 3. æ˜¾ç¤ºå¹¶æ ‡è®°è§£å†³æ–¹æ¡ˆè·¯å¾„ä¸­çš„å¡ç‰‡ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                if (this.solutionPath) {
                    this.solutionPath.forEach((nodeId) => {
                        const cardInfo = this.cards.get(nodeId);
                        if (cardInfo) {
                            cardInfo.element.classList.remove('hidden', 'exploration');
                            cardInfo.element.classList.add('solution');
                        }
                    });
                }

                // 4. æ˜¾ç¤ºå½“å‰æ´»è·ƒè·¯å¾„ä¸­çš„å¡ç‰‡
                if (this.pathMode === 'exploring') {
                    this.currentPath.forEach((nodeId) => {
                        const cardInfo = this.cards.get(nodeId);
                        if (cardInfo) {
                            cardInfo.element.classList.remove('hidden', 'exploration');
                        cardInfo.element.classList.add('active');
                    }
                });

                    // 5. æ˜¾ç¤ºå½“å‰èŠ‚ç‚¹çš„ç›´æ¥å­èŠ‚ç‚¹
                const currentNodeId = this.currentPath[this.currentPath.length - 1];
                const currentNode = this.findNodeInData(mindmapData, currentNodeId);
                
                if (currentNode && currentNode.children) {
                    currentNode.children.forEach(child => {
                        const childCardInfo = this.cards.get(child.id);
                        if (childCardInfo) {
                            childCardInfo.element.classList.remove('hidden');
                                }
                            });
                    }
                        }
                
                // æ›´æ–°è¿æ¥çº¿ä½ç½®å’Œæ˜¾ç¤ºçŠ¶æ€ï¼ˆåªåœ¨è¿æ¥çº¿å¯è§æ—¶ï¼‰
                if (this.svg.classList.contains('visible')) {
                    setTimeout(() => {
                        this.updateAllConnectionPositions();
                        this.updateConnectionLines();
                    }, 50); // ç­‰å¾…DOMæ›´æ–°å®Œæˆ
                }
            }

            updateConnectionLines() {
                // å…ˆæ›´æ–°æ‰€æœ‰è¿æ¥çº¿ä½ç½®
                this.updateAllConnectionPositions();
                
                // è·å–æ‰€æœ‰è¿æ¥çº¿
                const lines = this.svg.querySelectorAll('.connection-line');
                
                // é‡ç½®æ‰€æœ‰è¿æ¥çº¿çŠ¶æ€ï¼ŒåŒ…æ‹¬æœç´¢æ ·å¼
                lines.forEach(line => {
                    line.classList.remove('visible', 'active', 'exploration', 'solution', 'search-path');
                    line.setAttribute('marker-end', 'url(#arrowhead)');
                });

                // æ˜¾ç¤ºæ¢ç´¢è·¯å¾„çš„è¿æ¥çº¿
                this.explorationPaths.forEach(path => {
                    for (let i = 0; i < path.length - 1; i++) {
                        const fromId = path[i];
                        const toId = path[i + 1];
                        
                        const pathLine = Array.from(lines).find(line => 
                            line.dataset.from === fromId && line.dataset.to === toId
                        );
                        
                        if (pathLine) {
                            pathLine.classList.add('visible', 'exploration');
                        }
                    }
                });

                // æ˜¾ç¤ºè§£å†³æ–¹æ¡ˆè·¯å¾„çš„è¿æ¥çº¿ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                if (this.solutionPath) {
                    for (let i = 0; i < this.solutionPath.length - 1; i++) {
                        const fromId = this.solutionPath[i];
                        const toId = this.solutionPath[i + 1];
                        
                        const pathLine = Array.from(lines).find(line => 
                            line.dataset.from === fromId && line.dataset.to === toId
                        );
                        
                        if (pathLine) {
                            pathLine.classList.remove('exploration');
                            pathLine.classList.add('visible', 'solution');
                            pathLine.setAttribute('marker-end', 'url(#activeArrow)');
                        }
                    }
                }

                // æ˜¾ç¤ºå½“å‰æ´»è·ƒè·¯å¾„çš„è¿æ¥çº¿
                if (this.pathMode === 'exploring') {
                for (let i = 0; i < this.currentPath.length - 1; i++) {
                    const fromId = this.currentPath[i];
                    const toId = this.currentPath[i + 1];
                    
                    const pathLine = Array.from(lines).find(line => 
                        line.dataset.from === fromId && line.dataset.to === toId
                    );
                    
                    if (pathLine) {
                            pathLine.classList.remove('exploration');
                        pathLine.classList.add('visible', 'active');
                        pathLine.setAttribute('marker-end', 'url(#activeArrow)');
                    }
                }

                // æ˜¾ç¤ºå½“å‰èŠ‚ç‚¹çš„å­è¿æ¥çº¿
                const currentNodeId = this.currentPath[this.currentPath.length - 1];
                const currentNode = this.findNodeInData(mindmapData, currentNodeId);
                
                if (currentNode && currentNode.children) {
                    currentNode.children.forEach(child => {
                        const childLine = Array.from(lines).find(line => 
                            line.dataset.from === currentNodeId && line.dataset.to === child.id
                        );
                        
                        if (childLine) {
                            childLine.classList.add('visible');
                    }
                });
                    }
            }
            }

            // åœ¨æ•°æ®ç»“æ„ä¸­æŸ¥æ‰¾èŠ‚ç‚¹
            findNodeInData(node, targetId) {
                if (node.id === targetId) {
                    return node;
                }
                
                if (node.children) {
                    for (const child of node.children) {
                        const result = this.findNodeInData(child, targetId);
                        if (result) {
                            return result;
                        }
                    }
                }
                
                return null;
            }


            centerView() {
                this.scale = 1.0;
                this.translateX = 50; // è®©æ ¹å¡ç‰‡æ˜¾ç¤ºåœ¨å·¦ä¾§åˆé€‚ä½ç½®
                this.translateY = window.innerHeight / 2 - 150; // å‚ç›´å±…ä¸­
                this.updateTransform();
            }

            goBackOneStep() {
                if (this.pathMode === 'confirmed') {
                    console.log('è§£å†³æ–¹æ¡ˆå·²ç¡®è®¤ï¼Œæ— æ³•å›é€€');
                    return;
                }
                
                if (this.currentPath.length > 1) {
                    this.currentPath.pop(); // ç§»é™¤æœ€åä¸€ä¸ªèŠ‚ç‚¹
                    this.updateDisplay();
                }
            }

            // å°è¯•å¦ä¸€æ¡è·¯å¾„ï¼ˆå°†å½“å‰è·¯å¾„åŠ å…¥æ¢ç´¢è·¯å¾„ï¼‰
            tryAnotherPath() {
                if (this.pathMode === 'confirmed') {
                    console.log('è§£å†³æ–¹æ¡ˆå·²ç¡®è®¤ï¼Œæ— æ³•å°è¯•æ–°è·¯å¾„');
                    return;
                }
                
                if (this.currentPath.length > 1) {
                    // å°†å½“å‰è·¯å¾„åŠ å…¥æ¢ç´¢è·¯å¾„
                    this.explorationPaths.push([...this.currentPath]);
                    console.log('å°†è·¯å¾„åŠ å…¥æ¢ç´¢:', this.currentPath);
                    
                    // é‡ç½®åˆ°æ ¹èŠ‚ç‚¹
                    this.currentPath = ['root'];
                    this.updateDisplay();
                }
            }

            // ç¡®è®¤å½“å‰è·¯å¾„ä¸ºè§£å†³æ–¹æ¡ˆ
            confirmSolution() {
                if (this.currentPath.length > 1) {
                    this.solutionPath = [...this.currentPath];
                    this.pathMode = 'confirmed';
                    console.log('ç¡®è®¤è§£å†³æ–¹æ¡ˆè·¯å¾„:', this.solutionPath);
                    this.updateDisplay();
                    
                    // æ˜¾ç¤ºå¤åˆ¶æŒ‰é’®
                    document.getElementById('copyBtn').style.display = 'block';
                }
            }

            // é‡ç½®æ‰€æœ‰çŠ¶æ€
            resetToInitialState() {
                this.currentPath = ['root'];
                this.explorationPaths = [];
                this.solutionPath = null;
                this.pathMode = 'exploring';
                this.clearKeyboardFocus();
                this.svg.classList.remove('visible');
                
                // æ¸…é™¤æœç´¢çŠ¶æ€
                this.clearSearch();
                
                // éšè—å¤åˆ¶æŒ‰é’®
                document.getElementById('copyBtn').style.display = 'none';
                
                this.updateDisplay();
            }

            // æ‰§è¡Œæœç´¢å¹¶ç”Ÿæˆå»ºè®®
            performSearchWithSuggestions(query) {
                console.log('æ‰§è¡Œæœç´¢:', query);
                this.isSearchActive = true;
                this.searchResults = [];
                this.searchSuggestions = [];
                
                // åœ¨æ‰€æœ‰èŠ‚ç‚¹ä¸­æœç´¢åŒ¹é…çš„æ–‡æœ¬
                this.searchInDataRecursivelyWithDetails(mindmapData, query.toLowerCase(), []);
                
                console.log('æœç´¢ç»“æœ:', this.searchResults);
                console.log('æœç´¢å»ºè®®:', this.searchSuggestions);
                
                if (this.searchResults.length > 0) {
                    // æ˜¾ç¤ºè¿æ¥çº¿ï¼ˆå¦‚æœè¿˜æ²¡æ˜¾ç¤ºï¼‰
                    if (!this.svg.classList.contains('visible')) {
                        this.svg.classList.add('visible');
                    }
                    
                    // æ˜¾ç¤ºå»ºè®®æ¡†
                    this.showSuggestions();
                    
                    // æ›´æ–°æ˜¾ç¤º
                    this.updateDisplayWithSearch();
                } else {
                    this.hideSuggestions();
                }
            }

            // æ‰§è¡Œæœç´¢ï¼ˆå…¼å®¹æ—§ç‰ˆæœ¬ï¼‰
            performSearch(query) {
                this.performSearchWithSuggestions(query);
            }

            // é€’å½’æœç´¢æ•°æ®ç»“æ„ï¼ˆå¸¦è¯¦ç»†ä¿¡æ¯ï¼‰
            searchInDataRecursivelyWithDetails(node, query, currentPath) {
                const newPath = [...currentPath, { id: node.id, text: node.text }];
                
                // æ£€æŸ¥å½“å‰èŠ‚ç‚¹æ˜¯å¦åŒ¹é…
                if (node.text && node.text.toLowerCase().includes(query)) {
                    this.searchResults.push(node.id);
                    
                    // ç”Ÿæˆå»ºè®®é¡¹
                    const suggestion = {
                        id: node.id,
                        title: node.text,
                        path: this.generatePathString(newPath.slice(0, -1)), // ä¸åŒ…å«å½“å‰èŠ‚ç‚¹çš„è·¯å¾„
                        fullPath: newPath,
                        matchIndex: node.text.toLowerCase().indexOf(query)
                    };
                    
                    this.searchSuggestions.push(suggestion);
                }
                
                // é€’å½’æœç´¢å­èŠ‚ç‚¹
                if (node.children) {
                    node.children.forEach(child => {
                        this.searchInDataRecursivelyWithDetails(child, query, newPath);
                    });
                }
            }

            // é€’å½’æœç´¢æ•°æ®ç»“æ„ï¼ˆå…¼å®¹æ—§ç‰ˆæœ¬ï¼‰
            searchInDataRecursively(node, query) {
                // æ£€æŸ¥å½“å‰èŠ‚ç‚¹æ˜¯å¦åŒ¹é…
                if (node.text && node.text.toLowerCase().includes(query)) {
                    this.searchResults.push(node.id);
                }
                
                // é€’å½’æœç´¢å­èŠ‚ç‚¹
                if (node.children) {
                    node.children.forEach(child => {
                        this.searchInDataRecursively(child, query);
                    });
                }
            }

            // ç”Ÿæˆè·¯å¾„å­—ç¬¦ä¸²
            generatePathString(pathNodes) {
                if (pathNodes.length === 0) return 'æ ¹èŠ‚ç‚¹';
                return pathNodes.slice(1).map(node => node.text).join(' â†’ ');
            }

            // æ˜¾ç¤ºæœç´¢å»ºè®®
            showSuggestions() {
                const searchSuggestions = document.getElementById('searchSuggestions');
                const suggestionsList = document.getElementById('suggestionsList');
                
                if (!searchSuggestions || !suggestionsList) return;
                
                // æ¸…ç©ºç°æœ‰å»ºè®®
                suggestionsList.innerHTML = '';
                
                // ç”Ÿæˆå»ºè®®é¡¹
                this.searchSuggestions.forEach((suggestion, index) => {
                    const suggestionItem = document.createElement('div');
                    suggestionItem.className = 'suggestion-item';
                    suggestionItem.dataset.index = index;
                    
                    // é«˜äº®åŒ¹é…çš„æ–‡å­—
                    const query = document.getElementById('searchInput').value.trim().toLowerCase();
                    const highlightedTitle = this.highlightMatch(suggestion.title, query);
                    
                    suggestionItem.innerHTML = `
                        <div class="suggestion-content">
                            <div class="suggestion-title">${highlightedTitle}</div>
                            <div class="suggestion-path">${suggestion.path}</div>
                        </div>
                        <div class="suggestion-icon">â†’</div>
                    `;
                    
                    // ç‚¹å‡»äº‹ä»¶
                    suggestionItem.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        console.log('ç‚¹å‡»å»ºè®®é¡¹:', index, suggestion);
                        this.selectSuggestion(index);
                    });

                    // é¼ æ ‡è¿›å…¥æ—¶é«˜äº®
                    suggestionItem.addEventListener('mouseenter', () => {
                        const suggestionItems = document.querySelectorAll('.suggestion-item');
                        suggestionItems.forEach(item => item.classList.remove('highlighted'));
                        suggestionItem.classList.add('highlighted');
                        this.currentSuggestionIndex = index;
                    });
                    
                    suggestionsList.appendChild(suggestionItem);
                });
                
                // æ˜¾ç¤ºå»ºè®®æ¡†
                searchSuggestions.style.display = 'block';
                this.currentSuggestionIndex = -1;
            }

            // éšè—æœç´¢å»ºè®®
            hideSuggestions() {
                const searchSuggestions = document.getElementById('searchSuggestions');
                if (searchSuggestions) {
                    searchSuggestions.style.display = 'none';
                }
                this.currentSuggestionIndex = -1;
            }

            // é«˜äº®åŒ¹é…æ–‡å­—
            highlightMatch(text, query) {
                if (!query) return text;
                
                const index = text.toLowerCase().indexOf(query);
                if (index === -1) return text;
                
                const before = text.substring(0, index);
                const match = text.substring(index, index + query.length);
                const after = text.substring(index + query.length);
                
                return `${before}<span class="suggestion-match">${match}</span>${after}`;
            }

            // é”®ç›˜å¯¼èˆªå»ºè®®æ¡†
            navigateSuggestions(direction) {
                if (this.searchSuggestions.length === 0) return;
                
                const suggestionItems = document.querySelectorAll('.suggestion-item');
                
                // æ¸…é™¤ä¹‹å‰çš„é«˜äº®
                suggestionItems.forEach(item => item.classList.remove('highlighted'));
                
                // è®¡ç®—æ–°çš„ç´¢å¼•
                if (direction === 'down') {
                    this.currentSuggestionIndex = (this.currentSuggestionIndex + 1) % this.searchSuggestions.length;
                } else {
                    this.currentSuggestionIndex = this.currentSuggestionIndex <= 0 
                        ? this.searchSuggestions.length - 1 
                        : this.currentSuggestionIndex - 1;
                }
                
                // é«˜äº®å½“å‰é¡¹
                if (suggestionItems[this.currentSuggestionIndex]) {
                    suggestionItems[this.currentSuggestionIndex].classList.add('highlighted');
                    suggestionItems[this.currentSuggestionIndex].scrollIntoView({ block: 'nearest' });
                }
            }

            // é€‰æ‹©å½“å‰å»ºè®®é¡¹
            selectCurrentSuggestion() {
                if (this.currentSuggestionIndex >= 0 && this.currentSuggestionIndex < this.searchSuggestions.length) {
                    this.selectSuggestion(this.currentSuggestionIndex);
                } else if (this.searchSuggestions.length > 0) {
                    // å¦‚æœæ²¡æœ‰é€‰ä¸­é¡¹ï¼Œé€‰æ‹©ç¬¬ä¸€é¡¹
                    this.selectSuggestion(0);
                }
            }

            // é€‰æ‹©ç‰¹å®šå»ºè®®é¡¹
            selectSuggestion(index) {
                console.log('é€‰æ‹©å»ºè®®é¡¹:', index, this.searchSuggestions.length);
                
                if (index < 0 || index >= this.searchSuggestions.length) {
                    console.log('å»ºè®®é¡¹ç´¢å¼•æ— æ•ˆ');
                    return;
                }
                
                const suggestion = this.searchSuggestions[index];
                console.log('é€‰ä¸­çš„å»ºè®®:', suggestion);
                
                // å¯¼èˆªåˆ°é€‰ä¸­çš„èŠ‚ç‚¹
                const newPath = this.buildPathToNode(suggestion.id);
                if (newPath) {
                    console.log('å¯¼èˆªåˆ°è·¯å¾„:', newPath);
                    this.currentPath = newPath;
                    this.hideSuggestions();
                    
                    // åˆ‡æ¢åˆ°èšç„¦æ¨¡å¼ï¼Œåªæ˜¾ç¤ºé€‰ä¸­çš„èŠ‚ç‚¹å’Œè·¯å¾„
                    this.switchToFocusMode(suggestion.id);
                    
                    // è®¾ç½®é”®ç›˜ç„¦ç‚¹åˆ°ç›®æ ‡èŠ‚ç‚¹
                    setTimeout(() => {
                        this.setKeyboardFocus(suggestion.id);
                    }, 100);
                } else {
                    console.log('æ— æ³•æ„å»ºåˆ°èŠ‚ç‚¹çš„è·¯å¾„:', suggestion.id);
                }
            }

            // åˆ‡æ¢åˆ°èšç„¦æ¨¡å¼ï¼Œåªæ˜¾ç¤ºé€‰ä¸­çš„èŠ‚ç‚¹
            switchToFocusMode(focusNodeId) {
                console.log('åˆ‡æ¢åˆ°èšç„¦æ¨¡å¼:', focusNodeId);
                
                // è¿›å…¥èšç„¦æ¨¡å¼
                this.isFocusMode = true;
                
                // æ¸…é™¤æ‰€æœ‰æœç´¢ç»“æœï¼Œåªä¿ç•™èšç„¦çš„èŠ‚ç‚¹
                this.searchResults = [focusNodeId];
                
                // æ¸…é™¤å…¶ä»–æœç´¢å»ºè®®
                this.searchSuggestions = this.searchSuggestions.filter(s => s.id === focusNodeId);
                
                // æ›´æ–°æ˜¾ç¤º
                this.updateDisplayWithFocus();
            }

            // èšç„¦æ¨¡å¼çš„æ˜¾ç¤ºæ›´æ–°ï¼ˆåªæ˜¾ç¤ºé€‰ä¸­èŠ‚ç‚¹çš„è·¯å¾„ï¼‰
            updateDisplayWithFocus() {
                console.log('=== æ›´æ–°èšç„¦æ˜¾ç¤º ===');
                console.log('èšç„¦èŠ‚ç‚¹:', this.searchResults[0]);
                console.log('å½“å‰è·¯å¾„:', this.currentPath);
                
                // 1. é‡ç½®æ‰€æœ‰å¡ç‰‡çŠ¶æ€
                this.cards.forEach((cardInfo, nodeId) => {
                    cardInfo.element.classList.add('hidden');
                    cardInfo.element.classList.remove('active', 'exploration', 'solution', 'search-match', 'search-path');
                });

                // 2. åªæ˜¾ç¤ºå½“å‰è·¯å¾„ä¸Šçš„èŠ‚ç‚¹
                this.currentPath.forEach((nodeId) => {
                    const cardInfo = this.cards.get(nodeId);
                    if (cardInfo) {
                        cardInfo.element.classList.remove('hidden');
                        
                        // å¦‚æœæ˜¯ç›®æ ‡èŠ‚ç‚¹ï¼Œæ ‡è®°ä¸ºæœç´¢åŒ¹é…
                        if (nodeId === this.searchResults[0]) {
                            cardInfo.element.classList.add('search-match');
                        } else {
                            cardInfo.element.classList.add('search-path');
                        }
                    }
                });

                // 3. æ˜¾ç¤ºç›®æ ‡èŠ‚ç‚¹çš„ç›´æ¥å­èŠ‚ç‚¹ï¼ˆå¦‚æœæœ‰ï¼‰
                const targetNodeId = this.searchResults[0];
                const targetNode = this.findNodeInData(mindmapData, targetNodeId);
                
                if (targetNode && targetNode.children) {
                    targetNode.children.forEach(child => {
                        const childCardInfo = this.cards.get(child.id);
                        if (childCardInfo) {
                            childCardInfo.element.classList.remove('hidden');
                        }
                    });
                }
                
                // æ›´æ–°è¿æ¥çº¿ä½ç½®å’Œæ˜¾ç¤ºçŠ¶æ€
                setTimeout(() => {
                    this.updateAllConnectionPositions();
                    this.updateConnectionLinesWithFocus();
                }, 50); // ç­‰å¾…DOMæ›´æ–°å®Œæˆ
            }

            // èšç„¦æ¨¡å¼çš„è¿æ¥çº¿æ›´æ–°
            updateConnectionLinesWithFocus() {
                // è·å–æ‰€æœ‰è¿æ¥çº¿
                const lines = this.svg.querySelectorAll('.connection-line');
                
                // é‡ç½®æ‰€æœ‰è¿æ¥çº¿çŠ¶æ€
                lines.forEach(line => {
                    line.classList.remove('visible', 'active', 'exploration', 'solution', 'search-path');
                    line.setAttribute('marker-end', 'url(#arrowhead)');
                });

                // åªæ˜¾ç¤ºå½“å‰è·¯å¾„çš„è¿æ¥çº¿
                for (let i = 0; i < this.currentPath.length - 1; i++) {
                    const fromId = this.currentPath[i];
                    const toId = this.currentPath[i + 1];
                    
                    const pathLine = Array.from(lines).find(line => 
                        line.dataset.from === fromId && line.dataset.to === toId
                    );
                    
                    if (pathLine) {
                        pathLine.classList.add('visible', 'search-path');
                    }
                }

                // æ˜¾ç¤ºç›®æ ‡èŠ‚ç‚¹çš„å­è¿æ¥çº¿
                const targetNodeId = this.searchResults[0];
                const targetNode = this.findNodeInData(mindmapData, targetNodeId);
                
                if (targetNode && targetNode.children) {
                    targetNode.children.forEach(child => {
                        const childLine = Array.from(lines).find(line => 
                            line.dataset.from === targetNodeId && line.dataset.to === child.id
                        );
                        
                        if (childLine) {
                            childLine.classList.add('visible');
                        }
                    });
                }
            }

            // æ¸…é™¤æœç´¢
            clearSearch() {
                console.log('æ¸…é™¤æœç´¢');
                this.isSearchActive = false;
                this.isFocusMode = false;
                this.searchResults = [];
                this.searchSuggestions = [];
                
                // æ¸…ç©ºæœç´¢æ¡†
                const searchInput = document.getElementById('searchInput');
                const searchClearBtn = document.getElementById('searchClearBtn');
                if (searchInput) searchInput.value = '';
                if (searchClearBtn) searchClearBtn.style.display = 'none';
                
                // éšè—å»ºè®®æ¡†
                this.hideSuggestions();
                
                // æ¸…é™¤æ‰€æœ‰æœç´¢ç›¸å…³çš„æ ·å¼
                this.clearSearchStyles();
                
                // æ¢å¤æ™®é€šæ˜¾ç¤º
                this.updateDisplay();
            }

            // æ¸…é™¤æœç´¢ç›¸å…³çš„æ ·å¼
            clearSearchStyles() {
                // æ¸…é™¤æ‰€æœ‰å¡ç‰‡çš„æœç´¢æ ·å¼
                this.cards.forEach((cardInfo, nodeId) => {
                    cardInfo.element.classList.remove('search-match', 'search-path');
                });

                // æ¸…é™¤æ‰€æœ‰è¿æ¥çº¿çš„æœç´¢æ ·å¼
                const lines = this.svg.querySelectorAll('.connection-line');
                lines.forEach(line => {
                    line.classList.remove('search-path');
                    // é‡ç½®ç®­å¤´æ ‡è®°ä¸ºé»˜è®¤çŠ¶æ€
                    if (!line.classList.contains('active') && !line.classList.contains('solution')) {
                        line.setAttribute('marker-end', 'url(#arrowhead)');
                    }
                });
            }

            // å¯¼èˆªåˆ°æœç´¢ç»“æœ
            navigateToSearchResult(index) {
                if (!this.searchResults || index >= this.searchResults.length) return;
                
                const targetNodeId = this.searchResults[index];
                const newPath = this.buildPathToNode(targetNodeId);
                
                if (newPath) {
                    this.currentPath = newPath;
                    this.updateDisplayWithSearch();
                    
                    // è®¾ç½®é”®ç›˜ç„¦ç‚¹åˆ°ç›®æ ‡èŠ‚ç‚¹
                    setTimeout(() => {
                        this.setKeyboardFocus(targetNodeId);
                    }, 100);
                }
            }

            // å¸¦æœç´¢ç»“æœçš„æ˜¾ç¤ºæ›´æ–°
            updateDisplayWithSearch() {
                console.log('=== æ›´æ–°æœç´¢æ˜¾ç¤º ===');
                console.log('å½“å‰è·¯å¾„:', this.currentPath);
                console.log('æœç´¢ç»“æœ:', this.searchResults);
                
                // 1. é‡ç½®æ‰€æœ‰å¡ç‰‡çŠ¶æ€
                this.cards.forEach((cardInfo, nodeId) => {
                    cardInfo.element.classList.add('hidden');
                    cardInfo.element.classList.remove('active', 'exploration', 'solution', 'search-match', 'search-path');
                });

                // 2. æ˜¾ç¤ºå¹¶æ ‡è®°æœç´¢ç»“æœ
                this.searchResults.forEach(nodeId => {
                    const cardInfo = this.cards.get(nodeId);
                    if (cardInfo) {
                        cardInfo.element.classList.remove('hidden');
                        cardInfo.element.classList.add('search-match');
                    }
                });

                // 3. æ˜¾ç¤ºæœç´¢ç»“æœçš„è·¯å¾„
                const searchPaths = new Set();
                this.searchResults.forEach(nodeId => {
                    const pathToNode = this.buildPathToNode(nodeId);
                    if (pathToNode) {
                        pathToNode.forEach(pathNodeId => {
                            searchPaths.add(pathNodeId);
                        });
                    }
                });

                searchPaths.forEach(nodeId => {
                    const cardInfo = this.cards.get(nodeId);
                    if (cardInfo && !cardInfo.element.classList.contains('search-match')) {
                        cardInfo.element.classList.remove('hidden');
                        cardInfo.element.classList.add('search-path');
                    }
                });

                // 4. æ˜¾ç¤ºå½“å‰æ´»è·ƒè·¯å¾„ä¸­çš„å¡ç‰‡
                this.currentPath.forEach((nodeId) => {
                    const cardInfo = this.cards.get(nodeId);
                    if (cardInfo) {
                        cardInfo.element.classList.remove('hidden');
                        if (!cardInfo.element.classList.contains('search-match') && 
                            !cardInfo.element.classList.contains('search-path')) {
                            cardInfo.element.classList.add('active');
                        }
                    }
                });

                // 5. æ˜¾ç¤ºå½“å‰èŠ‚ç‚¹çš„ç›´æ¥å­èŠ‚ç‚¹
                const currentNodeId = this.currentPath[this.currentPath.length - 1];
                const currentNode = this.findNodeInData(mindmapData, currentNodeId);
                
                if (currentNode && currentNode.children) {
                    currentNode.children.forEach(child => {
                        const childCardInfo = this.cards.get(child.id);
                        if (childCardInfo) {
                            childCardInfo.element.classList.remove('hidden');
                        }
                    });
                }
                
                // æ›´æ–°è¿æ¥çº¿ä½ç½®å’Œæ˜¾ç¤ºçŠ¶æ€
                setTimeout(() => {
                    this.updateAllConnectionPositions();
                    this.updateConnectionLinesWithSearch();
                }, 50); // ç­‰å¾…DOMæ›´æ–°å®Œæˆ
            }

            // å¸¦æœç´¢åŠŸèƒ½çš„è¿æ¥çº¿æ›´æ–°
            updateConnectionLinesWithSearch() {
                // è·å–æ‰€æœ‰è¿æ¥çº¿
                const lines = this.svg.querySelectorAll('.connection-line');
                
                // é‡ç½®æ‰€æœ‰è¿æ¥çº¿çŠ¶æ€
                lines.forEach(line => {
                    line.classList.remove('visible', 'active', 'exploration', 'solution', 'search-path');
                    line.setAttribute('marker-end', 'url(#arrowhead)');
                });

                // æ˜¾ç¤ºæœç´¢è·¯å¾„çš„è¿æ¥çº¿
                const searchPaths = new Set();
                this.searchResults.forEach(nodeId => {
                    const pathToNode = this.buildPathToNode(nodeId);
                    if (pathToNode) {
                        for (let i = 0; i < pathToNode.length - 1; i++) {
                            const fromId = pathToNode[i];
                            const toId = pathToNode[i + 1];
                            
                            const pathLine = Array.from(lines).find(line => 
                                line.dataset.from === fromId && line.dataset.to === toId
                            );
                            
                            if (pathLine) {
                                pathLine.classList.add('visible', 'search-path');
                            }
                        }
                    }
                });

                // æ˜¾ç¤ºå½“å‰æ´»è·ƒè·¯å¾„çš„è¿æ¥çº¿
                for (let i = 0; i < this.currentPath.length - 1; i++) {
                    const fromId = this.currentPath[i];
                    const toId = this.currentPath[i + 1];
                    
                    const pathLine = Array.from(lines).find(line => 
                        line.dataset.from === fromId && line.dataset.to === toId
                    );
                    
                    if (pathLine) {
                        if (!pathLine.classList.contains('search-path')) {
                            pathLine.classList.add('visible', 'active');
                            pathLine.setAttribute('marker-end', 'url(#activeArrow)');
                        }
                    }
                }

                // æ˜¾ç¤ºå½“å‰èŠ‚ç‚¹çš„å­è¿æ¥çº¿
                const currentNodeId = this.currentPath[this.currentPath.length - 1];
                const currentNode = this.findNodeInData(mindmapData, currentNodeId);
                
                if (currentNode && currentNode.children) {
                    currentNode.children.forEach(child => {
                        const childLine = Array.from(lines).find(line => 
                            line.dataset.from === currentNodeId && line.dataset.to === child.id
                        );
                        
                        if (childLine && !childLine.classList.contains('search-path')) {
                            childLine.classList.add('visible');
                        }
                    });
                }
            }

            // é«˜äº®æ˜¾ç¤ºç‰¹å®šçš„æ¢ç´¢è·¯å¾„
            highlightExplorationPath(nodeId) {
                // æ‰¾åˆ°åŒ…å«è¯¥èŠ‚ç‚¹çš„æ¢ç´¢è·¯å¾„
                const targetPath = this.explorationPaths.find(path => path.includes(nodeId));
                if (!targetPath) return;

                // é«˜äº®è¯¥è·¯å¾„ä¸Šçš„æ‰€æœ‰å¡ç‰‡
                targetPath.forEach(pathNodeId => {
                    const cardInfo = this.cards.get(pathNodeId);
                    if (cardInfo && cardInfo.element.classList.contains('exploration')) {
                        cardInfo.element.classList.add('highlighted');
                    }
                });

                // é«˜äº®è¯¥è·¯å¾„ä¸Šçš„æ‰€æœ‰è¿æ¥çº¿
                const lines = this.svg.querySelectorAll('.connection-line');
                for (let i = 0; i < targetPath.length - 1; i++) {
                    const fromId = targetPath[i];
                    const toId = targetPath[i + 1];
                    
                    const pathLine = Array.from(lines).find(line => 
                        line.dataset.from === fromId && line.dataset.to === toId
                    );
                    
                    if (pathLine && pathLine.classList.contains('exploration')) {
                        pathLine.classList.add('highlighted');
                    }
                }
            }

            // å–æ¶ˆé«˜äº®æ¢ç´¢è·¯å¾„
            unhighlightExplorationPath() {
                // ç§»é™¤æ‰€æœ‰å¡ç‰‡çš„é«˜äº®çŠ¶æ€
                this.cards.forEach((cardInfo) => {
                    cardInfo.element.classList.remove('highlighted');
                });

                // ç§»é™¤æ‰€æœ‰è¿æ¥çº¿çš„é«˜äº®çŠ¶æ€
                const lines = this.svg.querySelectorAll('.connection-line');
                lines.forEach(line => {
                    line.classList.remove('highlighted');
                });
            }

            // åŒçº§èŠ‚ç‚¹å¯¼èˆªï¼ˆä¸Šä¸‹é”®ï¼‰
            navigateToSibling(direction) {
                // å¦‚æœæ²¡æœ‰ç„¦ç‚¹ï¼Œå…ˆå°è¯•ä»å¯è§çš„å­èŠ‚ç‚¹å¼€å§‹
                if (!this.keyboardFocusedCard) {
                    this.initializeKeyboardFocus();
                    return;
                }

                // è·å–å½“å‰ç„¦ç‚¹èŠ‚ç‚¹çš„åŒçº§èŠ‚ç‚¹
                const siblings = this.getSiblingsOfNode(this.keyboardFocusedCard);
                if (siblings.length <= 1) return; // æ²¡æœ‰å…„å¼ŸèŠ‚ç‚¹å¯ä»¥åˆ‡æ¢

                const currentIndex = siblings.findIndex(sibling => sibling.id === this.keyboardFocusedCard);
                if (currentIndex === -1) return; // å½“å‰èŠ‚ç‚¹ä¸åœ¨å…„å¼ŸèŠ‚ç‚¹åˆ—è¡¨ä¸­

                // æ ¹æ®æ–¹å‘è®¡ç®—æ–°çš„ç´¢å¼•
                let newIndex;
                if (direction === 'down') {
                    newIndex = (currentIndex + 1) % siblings.length;
                } else {
                    newIndex = currentIndex === 0 ? siblings.length - 1 : currentIndex - 1;
                }

                // è®¾ç½®æ–°çš„ç„¦ç‚¹
                this.setKeyboardFocus(siblings[newIndex].id);
            }

            // å¯¼èˆªåˆ°çˆ¶èŠ‚ç‚¹ï¼ˆå·¦é”®ï¼‰
            navigateToParent() {
                if (!this.keyboardFocusedCard) {
                    // å¦‚æœæ²¡æœ‰ç„¦ç‚¹ï¼Œè®¾ç½®ç„¦ç‚¹åˆ°å½“å‰è·¯å¾„çš„æœ€åä¸€ä¸ªèŠ‚ç‚¹
                    const lastNodeId = this.currentPath[this.currentPath.length - 1];
                    this.setKeyboardFocus(lastNodeId);
                    return;
                }

                // æ‰¾åˆ°å½“å‰ç„¦ç‚¹èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹
                const parentNode = this.findParentInData(this.keyboardFocusedCard);
                if (parentNode && this.isNodeVisible(parentNode.id)) {
                    this.setKeyboardFocus(parentNode.id);
                } else {
                    // å¦‚æœçˆ¶èŠ‚ç‚¹ä¸å¯è§ï¼Œå°è¯•å›åˆ°è·¯å¾„ä¸­çš„ä¸Šä¸€çº§
                    const focusedIndex = this.currentPath.indexOf(this.keyboardFocusedCard);
                    if (focusedIndex > 0) {
                        this.setKeyboardFocus(this.currentPath[focusedIndex - 1]);
                    }
                }
            }

            // å¯¼èˆªåˆ°å­èŠ‚ç‚¹ï¼ˆå³é”®ï¼‰
            navigateToChild() {
                if (!this.keyboardFocusedCard) {
                    this.initializeKeyboardFocus();
                    return;
                }

                // æ£€æŸ¥å½“å‰ç„¦ç‚¹èŠ‚ç‚¹æ˜¯å¦æœ‰å¯è§çš„å­èŠ‚ç‚¹
                const focusedNodeData = this.findNodeInData(mindmapData, this.keyboardFocusedCard);
                if (!focusedNodeData || !focusedNodeData.children) return;

                // æ‰¾åˆ°ç¬¬ä¸€ä¸ªå¯è§çš„å­èŠ‚ç‚¹
                const firstVisibleChild = focusedNodeData.children.find(child => 
                    this.isNodeVisible(child.id)
                );

                if (firstVisibleChild) {
                    this.setKeyboardFocus(firstVisibleChild.id);
                } else {
                    // å¦‚æœæ²¡æœ‰å¯è§çš„å­èŠ‚ç‚¹ï¼Œå°è¯•å±•å¼€/é€‰æ‹©å½“å‰èŠ‚ç‚¹
                    this.selectFocusedCard();
                }
            }

            // åˆå§‹åŒ–é”®ç›˜ç„¦ç‚¹ï¼ˆè®¾ç½®åˆ°ç¬¬ä¸€ä¸ªå¯è§çš„å¯é€‰æ‹©èŠ‚ç‚¹ï¼‰
            initializeKeyboardFocus() {
                // ä¼˜å…ˆé€‰æ‹©å½“å‰è·¯å¾„çš„æœ€åä¸€ä¸ªèŠ‚ç‚¹
                const lastNodeId = this.currentPath[this.currentPath.length - 1];
                if (this.isNodeVisible(lastNodeId)) {
                    this.setKeyboardFocus(lastNodeId);
                    return;
                }

                // å¦åˆ™é€‰æ‹©ç¬¬ä¸€ä¸ªå¯è§çš„å­èŠ‚ç‚¹
                const lastNode = this.findNodeInData(mindmapData, lastNodeId);
                if (lastNode && lastNode.children) {
                    const firstVisibleChild = lastNode.children.find(child => 
                        this.isNodeVisible(child.id)
                    );
                    if (firstVisibleChild) {
                        this.setKeyboardFocus(firstVisibleChild.id);
                    }
                }
            }

            // è·å–æŒ‡å®šèŠ‚ç‚¹çš„åŒçº§èŠ‚ç‚¹
            getSiblingsOfNode(nodeId) {
                const parentNode = this.findParentInData(nodeId);
                if (!parentNode || !parentNode.children) return [];

                // æ‰¾åˆ°çˆ¶èŠ‚ç‚¹ä¸‹æ‰€æœ‰å¯è§çš„å­èŠ‚ç‚¹
                const siblings = parentNode.children
                    .filter(child => this.isNodeVisible(child.id))
                    .map(child => {
                        const cardInfo = this.cards.get(child.id);
                        return {
                            id: child.id,
                            data: child,
                            y: cardInfo ? cardInfo.y : 0
                        };
                    });

                // æŒ‰Yåæ ‡æ’åºï¼ˆä»ä¸Šåˆ°ä¸‹ï¼‰
                siblings.sort((a, b) => a.y - b.y);
                return siblings;
            }

            // æ£€æŸ¥èŠ‚ç‚¹æ˜¯å¦å¯è§
            isNodeVisible(nodeId) {
                const cardInfo = this.cards.get(nodeId);
                return cardInfo && !cardInfo.element.classList.contains('hidden');
            }


            // åœ¨æ•°æ®ç»“æ„ä¸­æ‰¾åˆ°æŸä¸ªèŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹
            findParentInData(targetId) {
                const findParent = (node, target, parent = null) => {
                    if (node.id === target) {
                        return parent;
                    }
                    if (node.children) {
                        for (const child of node.children) {
                            const result = findParent(child, target, node);
                            if (result) return result;
                        }
                    }
                    return null;
                };
                
                return findParent(mindmapData, targetId);
            }

            // è®¾ç½®é”®ç›˜ç„¦ç‚¹
            setKeyboardFocus(nodeId) {
                // æ¸…é™¤ä¹‹å‰çš„ç„¦ç‚¹
                this.clearKeyboardFocus();
                
                // è®¾ç½®æ–°ç„¦ç‚¹
                this.keyboardFocusedCard = nodeId;
                const cardInfo = this.cards.get(nodeId);
                if (cardInfo) {
                    cardInfo.element.classList.add('keyboard-focused');
                    console.log('é”®ç›˜ç„¦ç‚¹è®¾ç½®åˆ°:', nodeId);
                }
            }

            // æ¸…é™¤é”®ç›˜ç„¦ç‚¹
            clearKeyboardFocus() {
                if (this.keyboardFocusedCard) {
                    const cardInfo = this.cards.get(this.keyboardFocusedCard);
                    if (cardInfo) {
                        cardInfo.element.classList.remove('keyboard-focused');
                    }
                    this.keyboardFocusedCard = null;
                }
            }

            // é€‰æ‹©å½“å‰ç„¦ç‚¹çš„å¡ç‰‡
            selectFocusedCard() {
                if (this.keyboardFocusedCard) {
                    this.handleCardClick(this.keyboardFocusedCard);
                    // é€‰æ‹©åï¼Œè‡ªåŠ¨è®¾ç½®ç„¦ç‚¹åˆ°æ–°å±•å¼€çš„ç¬¬ä¸€ä¸ªå­èŠ‚ç‚¹ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰
                    setTimeout(() => {
                        const focusedNodeData = this.findNodeInData(mindmapData, this.keyboardFocusedCard);
                        if (focusedNodeData && focusedNodeData.children) {
                            const firstVisibleChild = focusedNodeData.children.find(child => 
                                this.isNodeVisible(child.id)
                            );
                            if (firstVisibleChild) {
                                this.setKeyboardFocus(firstVisibleChild.id);
                            }
                        }
                    }, 100);
                }
            }

            // ç”Ÿæˆè§£æ³•è·¯å¾„æ–‡æœ¬
            generateSolutionText() {
                if (!this.solutionPath || this.solutionPath.length === 0) {
                    return "æš‚æ— è§£æ³•è·¯å¾„";
                }

                // åªè¿”å›çº¯ç²¹çš„è§£é¢˜è·¯å¾„
                const solutionText = this.solutionPath.slice(1).map(nodeId => {
                    const nodeData = this.findNodeInData(mindmapData, nodeId);
                    return nodeData ? nodeData.text : nodeId;
                }).join(' â†’ ');

                return solutionText;
            }

            // å¤åˆ¶è§£æ³•è·¯å¾„åˆ°å‰ªè´´æ¿
            async copySolutionToClipboard() {
                const solutionText = this.generateSolutionText();
                
                try {
                    await navigator.clipboard.writeText(solutionText);
                    return true;
                } catch (err) {
                    // é™çº§æ–¹æ¡ˆï¼šä½¿ç”¨ä¼ ç»Ÿçš„å¤åˆ¶æ–¹æ³•
                    const textArea = document.createElement('textarea');
                    textArea.value = solutionText;
                    textArea.style.position = 'fixed';
                    textArea.style.left = '-999999px';
                    textArea.style.top = '-999999px';
                    document.body.appendChild(textArea);
                    textArea.focus();
                    textArea.select();
                    
                    try {
                        document.execCommand('copy');
                        document.body.removeChild(textArea);
                        return true;
                    } catch (err2) {
                        document.body.removeChild(textArea);
                        return false;
                    }
                }
            }

            // æ˜¾ç¤ºæ£€æŸ¥æ¸…å•å¼¹å‡ºæ¡†
            showChecklist(nodeData, indicatorElement) {
                // å…ˆå…³é—­å·²å­˜åœ¨çš„æ£€æŸ¥æ¸…å•å¼¹å‡ºæ¡†
                this.hideChecklist();
                
                if (!nodeData.checklist || nodeData.checklist.length === 0) {
                    return;
                }
                
                // åˆ›å»ºå¼¹å‡ºæ¡†
                const popup = document.createElement('div');
                popup.className = 'checklist-popup';
                popup.id = 'checklistPopup';
                
                // æ·»åŠ æ ‡é¢˜
                const title = document.createElement('div');
                title.className = 'checklist-title';
                title.textContent = `${nodeData.text} - æ£€æŸ¥æ¸…å•`;
                popup.appendChild(title);
                
                // æ·»åŠ å…³é—­æŒ‰é’®
                const closeBtn = document.createElement('button');
                closeBtn.className = 'close-btn';
                closeBtn.innerHTML = 'Ã—';
                closeBtn.addEventListener('click', () => this.hideChecklist());
                popup.appendChild(closeBtn);
                
                // æ·»åŠ æ£€æŸ¥æ¸…å•é¡¹
                nodeData.checklist.forEach(item => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = `checklist-item ${item.level > 0 ? 'level-1' : ''}`;
                    itemDiv.textContent = item.text;
                    popup.appendChild(itemDiv);
                });
                
                // å®šä½å¼¹å‡ºæ¡†
                const indicatorRect = indicatorElement.getBoundingClientRect();
                const containerRect = this.container.getBoundingClientRect();
                
                popup.style.left = (indicatorRect.left - containerRect.left + 30) + 'px';
                popup.style.top = (indicatorRect.top - containerRect.top - 10) + 'px';
                
                // æ·»åŠ åˆ°å®¹å™¨ä¸­
                this.container.appendChild(popup);
                
                // æ·»åŠ ç‚¹å‡»å¤–éƒ¨å…³é—­çš„äº‹ä»¶ç›‘å¬
                setTimeout(() => {
                    document.addEventListener('click', this.handleChecklistOutsideClick.bind(this), true);
                }, 100);
            }

            // éšè—æ£€æŸ¥æ¸…å•å¼¹å‡ºæ¡†
            hideChecklist() {
                const existingPopup = document.getElementById('checklistPopup');
                if (existingPopup) {
                    existingPopup.remove();
                    document.removeEventListener('click', this.handleChecklistOutsideClick.bind(this), true);
                }
            }

            // å¤„ç†ç‚¹å‡»å¤–éƒ¨å…³é—­æ£€æŸ¥æ¸…å•
            handleChecklistOutsideClick(event) {
                const popup = document.getElementById('checklistPopup');
                if (popup && !popup.contains(event.target)) {
                    this.hideChecklist();
                }
            }
        }

        // å…¨å±€å‡½æ•°
        function resetMindmap() {
            if (window.mindmapRenderer) {
                window.mindmapRenderer.resetToInitialState();
            } else {
            location.reload();
            }
        }

        function clearSearch() {
            if (window.mindmapRenderer) {
                window.mindmapRenderer.clearSearch();
            }
        }

        function centerView() {
            if (window.mindmapRenderer) {
                window.mindmapRenderer.centerView();
            }
        }


        function tryAnotherPath() {
            if (window.mindmapRenderer) {
                window.mindmapRenderer.tryAnotherPath();
            }
        }

        function confirmSolution() {
            if (window.mindmapRenderer) {
                window.mindmapRenderer.confirmSolution();
            }
        }

        async function copySolutionPath() {
            if (window.mindmapRenderer) {
                const copyBtn = document.getElementById('copyBtn');
                const originalText = copyBtn.textContent;
                
                try {
                    const success = await window.mindmapRenderer.copySolutionToClipboard();
                    
                    if (success) {
                        // æ˜¾ç¤ºæˆåŠŸåé¦ˆ
                        copyBtn.textContent = 'âœ… å·²å¤åˆ¶';
                        copyBtn.classList.add('copied');
                        
                        // 2ç§’åæ¢å¤åŸçŠ¶
                        setTimeout(() => {
                            copyBtn.textContent = originalText;
                            copyBtn.classList.remove('copied');
                        }, 2000);
                    } else {
                        // æ˜¾ç¤ºå¤±è´¥åé¦ˆ
                        copyBtn.textContent = 'âŒ å¤åˆ¶å¤±è´¥';
                        setTimeout(() => {
                            copyBtn.textContent = originalText;
                        }, 2000);
                    }
                } catch (error) {
                    console.error('å¤åˆ¶å¤±è´¥:', error);
                    copyBtn.textContent = 'âŒ å¤åˆ¶å¤±è´¥';
                    setTimeout(() => {
                        copyBtn.textContent = originalText;
                    }, 2000);
                }
            }
        }

        // åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', () => {
            window.mindmapRenderer = new GingkoMindmapRenderer();
        });

        // é”®ç›˜å¿«æ·é”®
        document.addEventListener('keydown', (e) => {
            if (e.key === 'F5' || (e.metaKey && e.key === 'r') || (e.ctrlKey && e.key === 'r')) {
                return; // å…è®¸åˆ·æ–°
            }
            if (e.key === 'c' || e.key === 'C') {
                centerView();
            }
            // Ctrl+F æˆ– Cmd+F æ¿€æ´»æœç´¢
            if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
                e.preventDefault();
                const searchInput = document.getElementById('searchInput');
                if (searchInput) {
                    searchInput.focus();
                    searchInput.select();
                }
            }
            // Escape æ¸…é™¤æœç´¢ï¼ˆå¦‚æœæœç´¢æ¡†æ²¡æœ‰ç„¦ç‚¹ï¼‰
            if (e.key === 'Escape') {
                const searchInput = document.getElementById('searchInput');
                if (searchInput && document.activeElement !== searchInput) {
                    clearSearch();
                }
            }
            // ç§»é™¤äº†å›é€€é”®å¤„ç†ï¼Œç°åœ¨ç”±é”®ç›˜å¯¼èˆªç³»ç»Ÿç»Ÿä¸€å¤„ç†æ–¹å‘é”®
        });
    </script>
</body>
</html>
