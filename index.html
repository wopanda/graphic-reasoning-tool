<script>
// ====== æ€ç»´å¯¼å›¾æ•°æ®ç»“æ„ï¼ˆMarkdownæ ¼å¼ï¼‰ ======
// ç›´æ¥åœ¨ç¬¬ä¸€è¡Œä¿®æ”¹ï¼Œä¿å­˜ååˆ·æ–°é¡µé¢å³å¯ç”Ÿæ•ˆ

const mindmapMarkdown = `
- ğŸ¯ å›¾å½¢æ¨ç†å†³ç­–
    - ğŸš€ æ„æˆç›¸ä¼¼
      - ğŸ‘‰ å…ƒç´ å®Œå…¨ç›¸åŒ â‡’ [ä½ç½®è§„å¾‹]
        - ç§»åŠ¨ç±»å‹ï¼šå¹³ç§»ã€æ—‹è½¬ã€ç¿»è½¬
        - ç§»åŠ¨è½½ä½“ (èƒŒæ™¯æ ¼)
          - å®«æ ¼ç±»ï¼šä¼˜å…ˆâ€œå†…å¤–åˆ†ç¦»â€ï¼Œå–„ç”¨â€œå¤§é¢ç§¯åŒºåŸŸæ³•â€
          - éå®«æ ¼ç±»ï¼šè‡ªè¡Œæ„å»ºå‚ç…§ç³»ï¼Œéµå¾ªâ€œå°±è¿‘åŸåˆ™â€
        - ç‰¹æ®Šæƒ…å†µï¼šæœ‰å…ƒç´ â€œä¸åŠ¨â€ â‡’ [ç›¸é‚»æ¯”è¾ƒ]
      - ğŸ‘‰ å…ƒç´ éƒ¨åˆ†ç›¸åŒ â‡’ [æ ·å¼è§„å¾‹]
        - é»‘ç™½å— (å¤–æ¡†ä¸€è‡´) â‡’ [é»‘ç™½è¿ç®—] (æŠ€å·§ï¼šæ‰¾â€œç›¸åŒåŒºåŸŸâ€ç§’æ€)
        - çº¿æ¡ (å¤–æ¡†ä¸ä¸€) â‡’ [åŠ å‡åŒå¼‚] (æ ¸å¿ƒï¼šä¼˜å…ˆéªŒè¯â€œæ±‚å¼‚â€)
        - æœ‰å­¤ç«‹â€œå°æ ‡è®°â€ â‡’ [æ ‡è®°è§„å¾‹] (åˆ†ææ ‡è®°ä¸ä¸»ä½“/æ ‡è®°ä¹‹é—´çš„å…³ç³»)
    - ğŸš€ æ„æˆå„å¼‚
      - ğŸ‘‰ ä¼˜å…ˆæŸ¥ [å±æ€§è§„å¾‹] (å®è§‚ç‰¹å¾)
        - å¯¹ç§° (æœ€é«˜ä¼˜å…ˆçº§)ï¼šè½´/ä¸­å¿ƒå¯¹ç§° (æ³¨æ„å†…éƒ¨å¡«å……)
        - æ›²ç›´ (è§¦å‘ï¼šä¸€åŠä»¥ä¸Šå›¾å½¢å«æ›²çº¿)
        - å¼€é—­ (è§¦å‘ï¼šâ€œç”Ÿæ´»åŒ–â€å›¾å½¢)
      - ğŸ‘‰ æ— æ˜æ˜¾å±æ€§ï¼Œåˆ™æŸ¥ [æ•°é‡è§„å¾‹]
        - å¼ºç‰¹å¾ä¼˜å…ˆ (çœ‹åˆ°å³æ•°)
          - â€œæ—¥/ç”°/äº”è§’æ˜Ÿ/åœ†ç›¸äº¤â€ â†’ [ç¬”ç”»]
          - â€œå›¾å½¢æ•£ä¹±ã€ä¸è¿æ¥â€ â†’ [å…ƒç´ ]
          - â€œåå­—/çŸ©å½¢/ç›´è§’ä¸‰è§’â€ â†’ [è§’(ç›´è§’)]
          - â€œæ¯å¹…å›¾éƒ½æœ‰æ›²çº¿â€ â†’ [çº¿(æ›²/ç›´/äº¤ç‚¹)]
          - â€œæ¯å¹…å›¾éƒ½ç”±2ä¸ªå…ƒç´ æ„æˆâ€ â†’ [å›¾å½¢å…³ç³»]
        - å…œåº•ç­–ç•¥ (æ— å¼ºç‰¹å¾æ—¶æŒ‰åºæ’æŸ¥)
          - 1. æ•° [é¢] (å°é—­ç©ºé—´)
          - 2. æ•° [ç¬”ç”»]
          - 3. æ•° [ç‚¹] (äº¤ç‚¹/ç«¯ç‚¹)
      - ğŸ‘‰ [é»‘ç™½å—] ç‰¹æ®Šå†³ç­–æ¨¡å—
        - è§„åˆ™/å¥½çœ‹ â†’ ä¼˜å…ˆæŸ¥ [å¯¹ç§°è½´]
        - æ•°é‡å°‘/é¢ç§¯å¤§ â†’ ä¼˜å…ˆæŸ¥ [ä½ç½®è§„å¾‹]
        - åˆ†å †å°‘ â†’ ä¼˜å…ˆæŸ¥ [éƒ¨åˆ†æ•°]
        - åˆ†å †å¤š/ä¹å®«æ ¼ â†’ ä¼˜å…ˆæŸ¥ [é»‘ç™½è¿ç®—]
        - (æœ€åæ‰è€ƒè™‘) â†’ é»‘å—/ç™½å— [ä¸ªæ•°]
`.trim();
</script>

<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å›¾Â·å¢ƒ - å›¾å½¢æ¨ç†æ€ç»´å¯¼å›¾</title>
    <style>
        /* åŸºç¡€é‡ç½®ä¸å­—ä½“ */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            color: #333333;
            line-height: 1.6;
            overflow: hidden;
            height: 100vh;
        }

        /* ä¸»å®¹å™¨ */
        .slate {
            width: 100vw;
            height: 100vh;
            position: relative;
            overflow: hidden;
        }

        /* æ€ç»´å¯¼å›¾ç”»å¸ƒ */
        .mindmap-canvas {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            cursor: grab;
            overflow: hidden;
            /* è§¦æ‘¸ä¼˜åŒ– */
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }

        .mindmap-canvas.dragging {
            cursor: grabbing;
        }

        /* æ€ç»´å¯¼å›¾å®¹å™¨ - ç®€åŒ–çš„æ¨ªå‘å¸ƒå±€ */
        .mindmap-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform-origin: 0 0;
            transition: transform 0.3s ease-out;
            padding: 60px;
        }

        /* å¡ç‰‡æ ·å¼ - Gingkoé£æ ¼ */
        .card {
            position: absolute;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.08);
            border: 1px solid #e1e8ed;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            width: 240px;
            overflow: hidden;
            /* è§¦æ‘¸ä¼˜åŒ– */
            touch-action: manipulation;
            -webkit-tap-highlight-color: rgba(0, 122, 255, 0.1);
        }

        .card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.12);
            border-color: #007AFF;
        }

        .card.active {
            border-color: #007AFF;
            box-shadow: 0 4px 20px rgba(0, 122, 255, 0.2);
            transform: translateY(-2px);
        }

        .card.active::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 4px;
            background: linear-gradient(135deg, #007AFF, #0056CC);
        }

        /* å¡ç‰‡å†…å®¹ */
        .card-content {
            padding: 16px 32px 16px 20px; /* å‡å°‘å³ä¾§å†…è¾¹è·åˆ°32pxï¼Œè®©æ–‡å­—å’Œæ•°å­—æ›´è¿‘ */
            font-size: 14px;
            font-weight: 500;
            color: #333;
            line-height: 1.4;
        }

        /* æ ¹èŠ‚ç‚¹å¡ç‰‡ */
        .card.root-card {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            max-width: 280px;
        }

        .card.root-card .card-content {
            font-size: 18px;
            font-weight: 600;
            padding: 24px 40px 24px 28px; /* å‡å°‘æ ¹èŠ‚ç‚¹å³ä¾§å†…è¾¹è· */
            text-align: center;
            color: white;
        }

        .card.root-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 25px rgba(102, 126, 234, 0.3);
        }

        /* ä¸€çº§åˆ†æ”¯å¡ç‰‡ */
        .card.branch-card {
            background: linear-gradient(135deg, #a8edea, #fed6e3);
            border: none;
        }

        .card.branch-card .card-content {
            font-size: 15px;
            font-weight: 600;
            color: #2d3748;
        }

        .card.branch-card.active {
            background: linear-gradient(135deg, #81e6d9, #fbb6ce);
        }

        /* å¶èŠ‚ç‚¹å¡ç‰‡ */
        .card.leaf-card {
            background: white;
        }

        .card.leaf-card .card-content {
            font-size: 13px;
            font-weight: 400;
            color: #4a5568;
        }

        /* æ¢ç´¢çŠ¶æ€çš„å¡ç‰‡ - èƒŒæ™¯å±‚ */
        .card.exploration {
            opacity: 0.4;
            background: #F8F9FA;
            border: 1px solid #E5E7EB;
            transform: scale(0.95);
            z-index: 1;
            transition: all 0.3s ease;
        }

        .card.exploration .card-content {
            color: #9CA3AF;
            font-size: 12px;
        }

        /* æ¢ç´¢å¡ç‰‡æ‚¬åœæ•ˆæœ */
        .card.exploration:hover,
        .card.exploration.highlighted {
            opacity: 0.8;
            transform: scale(1);
            background: #F3F4F6;
            border-color: #9CA3AF;
            z-index: 5;
        }

        .card.exploration:hover .card-content,
        .card.exploration.highlighted .card-content {
            color: #6B7280;
            font-size: 13px;
        }

        /* è§£å†³æ–¹æ¡ˆçŠ¶æ€çš„å¡ç‰‡ - ç»“æœå±‚ï¼ˆæœ€é«˜ä¼˜å…ˆçº§ï¼‰ */
        .card.solution {
            background: linear-gradient(135deg, #FEF3C7, #FDE68A);
            border: 2px solid #F59E0B;
            box-shadow: 0 4px 20px rgba(245, 158, 11, 0.3);
            z-index: 10;
            transform: scale(1.02);
        }

        .card.solution .card-content {
            color: #92400E;
            font-weight: 600;
        }

        /* å½“å‰æ´»è·ƒå¡ç‰‡ - äº¤äº’å±‚ */
        .card.active {
            z-index: 8;
        }

        /* é”®ç›˜ç„¦ç‚¹çŠ¶æ€ */
        .card.keyboard-focused {
            outline: 3px solid #007AFF;
            outline-offset: 2px;
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 6px 24px rgba(0, 122, 255, 0.25);
            transition: all 0.2s ease;
            z-index: 9;
        }

        .card.keyboard-focused.exploration {
            outline-color: #6B7280;
            box-shadow: 0 6px 24px rgba(107, 114, 128, 0.25);
        }

        .card.keyboard-focused.solution {
            outline-color: #F59E0B;
            box-shadow: 0 6px 24px rgba(245, 158, 11, 0.4);
        }

        /* å±•å¼€æŒ‡ç¤ºå™¨ */
        .expand-indicator {
            position: absolute;
            right: 8px; /* ç¨å¾®å‘å³ç§»åŠ¨ä¸€ç‚¹ */
            top: 50%;
            transform: translateY(-50%);
            width: 22px; /* ç¨å¾®å‡å°å°ºå¯¸ */
            height: 22px;
            border-radius: 50%;
            background: #f7fafc;
            border: 2px solid #e2e8f0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px; /* æ¢å¤åŸæ¥çš„å­—ä½“å¤§å° */
            font-weight: bold;
            color: #718096;
            transition: all 0.3s ease;
            z-index: 10; /* ç¡®ä¿æŒ‡ç¤ºå™¨åœ¨æœ€ä¸Šå±‚ */
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1); /* æ·»åŠ è½»å¾®é˜´å½± */
        }

        .card:hover .expand-indicator {
            background: #007AFF;
            border-color: #007AFF;
            color: white;
        }

        .card.active .expand-indicator {
            background: #007AFF;
            border-color: #007AFF;
            color: white;
        }

        /* è¿æ¥çº¿å®¹å™¨ */
        .connections-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5; /* é™ä½åŸºç¡€å±‚çº§ï¼Œè®©å¡ç‰‡å¯ä»¥æ˜¾ç¤ºåœ¨è¿çº¿ä¸Šæ–¹ */
            opacity: 0; /* åˆå§‹éšè—ï¼Œç­‰ç”¨æˆ·äº¤äº’åå†æ˜¾ç¤º */
            transition: opacity 0.3s ease;
            transform-origin: 0 0; /* ç¡®ä¿å˜æ¢åŸç‚¹ä¸å®¹å™¨ä¸€è‡´ */
            overflow: visible; /* ç¡®ä¿è¿æ¥çº¿ä¸ä¼šè¢«è£å‰ª */
        }

        .connections-svg.visible {
            opacity: 1; /* ç”¨æˆ·äº¤äº’åæ˜¾ç¤º */
        }

        /* æ‹–åŠ¨æ—¶éšè—è¿æ¥çº¿ */
        .connections-svg.dragging {
            opacity: 0;
            transition: opacity 0.1s ease;
        }

        /* å¯è§çš„è¿æ¥çº¿æ ·å¼ */
        .connection-line {
            fill: none;
            stroke: #e2e8f0;
            stroke-width: 2;
            opacity: 0; /* é»˜è®¤éšè—ï¼Œåªæœ‰visibleæˆ–activeæ—¶æ‰æ˜¾ç¤º */
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .connection-line.visible {
            opacity: 0.8;
            stroke: #cbd5e0;
            stroke-width: 3;
        }

        /* å½“å‰æ´»è·ƒè·¯å¾„æ ·å¼ - äº¤äº’å±‚ */
        .connection-line.active {
            opacity: 1;
            stroke: #007AFF;
            stroke-width: 4;
            filter: drop-shadow(0 2px 8px rgba(0, 122, 255, 0.3));
            animation: pathPulse 2s ease-in-out infinite;
            z-index: 8;
        }

        /* æ¢ç´¢è·¯å¾„æ ·å¼ - èƒŒæ™¯å±‚ */
        .connection-line.exploration {
            opacity: 0.25;
            stroke: #9CA3AF;
            stroke-width: 1.5;
            stroke-dasharray: 4, 4;
            z-index: 1;
            transition: all 0.3s ease;
        }

        /* æ¢ç´¢è·¯å¾„æ‚¬åœæ•ˆæœ */
        .connection-line.exploration:hover,
        .connection-line.exploration.highlighted {
            opacity: 0.6;
            stroke: #6B7280;
            stroke-width: 3;
            z-index: 5;
            stroke-dasharray: 6, 3;
        }

        /* è§£å†³æ–¹æ¡ˆè·¯å¾„æ ·å¼ - ç»“æœå±‚ï¼ˆæœ€é«˜ä¼˜å…ˆçº§ï¼‰ */
        .connection-line.solution {
            opacity: 1;
            stroke: #F59E0B;
            stroke-width: 5;
            filter: drop-shadow(0 3px 12px rgba(245, 158, 11, 0.4));
            animation: solutionPulse 3s ease-in-out infinite;
            z-index: 10;
        }

        /* è·¯å¾„è„‰åŠ¨åŠ¨ç”» */
        @keyframes pathPulse {
            0%, 100% {
                stroke-width: 4;
            opacity: 1;
            }
            50% {
                stroke-width: 5;
                opacity: 0.8;
            }
        }

        /* è§£å†³æ–¹æ¡ˆè·¯å¾„è„‰åŠ¨åŠ¨ç”» */
        @keyframes solutionPulse {
            0%, 100% {
                stroke-width: 5;
                opacity: 1;
            }
            50% {
                stroke-width: 6;
                opacity: 0.9;
                filter: drop-shadow(0 4px 16px rgba(245, 158, 11, 0.6));
            }
        }


        /* éšè—çŠ¶æ€ */
        .card.hidden {
            opacity: 0;
            transform: scale(0.8) translateY(10px);
            pointer-events: none;
        }

        /* é¡µé¢æ ‡é¢˜ï¼ˆéšè—ä½†ä¿æŒè¯­ä¹‰æ€§ï¼‰ */
        .page-title {
            position: absolute;
            left: -9999px;
            font-size: 1px;
        }

        /* ä¸“æ³¨æ¨¡å¼ï¼šç§»é™¤æ‰€æœ‰ä¸å¿…è¦çš„è§†è§‰å¹²æ‰° */
        :focus {
            outline: none;
        }

        ::selection {
            background-color: rgba(0, 122, 255, 0.2);
        }

        /* æ§åˆ¶é¢æ¿ */
        .controls {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            display: flex;
            gap: 10px;
        }

        /* ç‰ˆæƒä¿¡æ¯ - ç®€çº¦å·¦ä¸Šè§’ */
        .copyright-badge {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 999;
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 8px 12px;
            font-size: 11px;
            color: #666;
            border: 1px solid rgba(0, 0, 0, 0.05);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
            transition: all 0.3s ease;
            cursor: pointer;
            user-select: none;
        }

        .copyright-badge:hover {
            background: rgba(255, 255, 255, 0.95);
            color: #333;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .copyright-badge .author {
            font-weight: 500;
            color: #007AFF;
        }

        .copyright-badge .social {
            display: none;
            margin-top: 4px;
            font-size: 10px;
            color: #888;
            line-height: 1.3;
        }

        .copyright-badge:hover .social {
            display: block;
        }

        .control-btn {
            padding: 8px 16px;
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            color: #4a5568;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .control-btn:hover {
            background: #f7fafc;
            border-color: #007AFF;
            color: #007AFF;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        /* å¤åˆ¶æŒ‰é’®ç‰¹æ®Šæ ·å¼ */
        #copyBtn {
            background: linear-gradient(135deg, #10B981, #059669);
            color: white;
            border: none;
            font-weight: 600;
        }

        #copyBtn:hover {
            background: linear-gradient(135deg, #059669, #047857);
            color: white;
            border: none;
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(16, 185, 129, 0.3);
        }

        /* å¤åˆ¶æˆåŠŸåŠ¨ç”» */
        #copyBtn.copied {
            background: linear-gradient(135deg, #F59E0B, #D97706);
            animation: copySuccess 0.6s ease;
        }

        @keyframes copySuccess {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        /* å“åº”å¼è®¾è®¡ */
        @media (max-width: 768px) {
            .mindmap-container {
                padding: 20px;
            }
            
            .column {
                min-width: 200px;
                margin-right: 20px;
            }
            
            .card {
                max-width: 200px;
            }
            
            .card-content {
                padding: 12px 28px 12px 16px; /* ç§»åŠ¨ç«¯å‡å°‘å³ä¾§å†…è¾¹è· */
                font-size: 13px;
            }
            
            .card.root-card .card-content {
                font-size: 16px;
                padding: 18px 36px 18px 20px; /* ç§»åŠ¨ç«¯æ ¹èŠ‚ç‚¹å‡å°‘å³ä¾§å†…è¾¹è· */
            }

            /* ç§»åŠ¨ç«¯æ§åˆ¶é¢æ¿ä¼˜åŒ– */
            .controls {
                top: 10px;
                right: 10px;
                flex-wrap: wrap;
                max-width: 300px;
            }

            .control-btn {
                padding: 10px 12px;
                font-size: 11px;
                min-height: 44px; /* iOSæ¨èçš„æœ€å°è§¦æ‘¸ç›®æ ‡ */
                min-width: 60px;
                display: flex;
                align-items: center;
                justify-content: center;
                touch-action: manipulation;
            }

            /* ç§»åŠ¨ç«¯å±•å¼€æŒ‡ç¤ºå™¨ä¼˜åŒ– */
            .expand-indicator {
                width: 26px;
                height: 26px;
                font-size: 11px;
                right: 6px;
            }

            /* ç§»åŠ¨ç«¯ç‰ˆæƒä¿¡æ¯ä¼˜åŒ– */
            .copyright-badge {
                top: 10px;
                left: 10px;
                padding: 6px 10px;
                font-size: 10px;
                border-radius: 10px;
            }

            .copyright-badge .social {
                font-size: 9px;
            }
        }
    </style>
</head>
<body>
    <div class="slate">
        <h1 class="page-title">å›¾å½¢æ¨ç†æ€ç»´å¯¼å›¾</h1>
        
        <!-- ç‰ˆæƒä¿¡æ¯ -->
        <div class="copyright-badge">
            <span class="author">Â© panda</span>
            <div class="social">
                å°çº¢ä¹¦: å…¬è€ƒå°é¥­å›¢<br>
                å¾®ä¿¡ï¼šFeynmanda
            </div>
        </div>
        
        <!-- æ§åˆ¶é¢æ¿ -->
        <div class="controls">
            <button class="control-btn" onclick="resetMindmap()">é‡ç½® (F5)</button>
            <button class="control-btn" onclick="centerView()">å±…ä¸­</button>
            <button class="control-btn path-action-btn" onclick="tryAnotherPath()" id="tryAnotherBtn">æ¢è·¯</button>
            <button class="control-btn path-action-btn" onclick="confirmSolution()" id="confirmBtn">ç¡®è®¤è§£æ³•</button>
            <button class="control-btn path-action-btn" onclick="copySolutionPath()" id="copyBtn" style="display: none;">ğŸ“‹ å¤åˆ¶è§£æ³•</button>
        </div>

        <!-- æ€ç»´å¯¼å›¾ç”»å¸ƒ -->
        <div class="mindmap-canvas" id="mindmapCanvas">
            <svg class="connections-svg" id="connectionSvg">
                <defs>
                    <!-- æ¿€æ´»è·¯å¾„æ¸å˜ -->
                    <linearGradient id="activeGradient" x1="0%" y1="0%" x2="100%" y2="0%">
                        <stop offset="0%" style="stop-color:#007AFF;stop-opacity:1" />
                        <stop offset="50%" style="stop-color:#0056CC;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#007AFF;stop-opacity:1" />
                    </linearGradient>
                    
                    <!-- éæ¿€æ´»è·¯å¾„æ¸å˜ -->
                    <linearGradient id="inactiveGradient" x1="0%" y1="0%" x2="100%" y2="0%">
                        <stop offset="0%" style="stop-color:#cbd5e0;stop-opacity:0.6" />
                        <stop offset="100%" style="stop-color:#e2e8f0;stop-opacity:0.6" />
                    </linearGradient>
                    
                    <!-- é»˜è®¤è¿æ¥çº¿æ¸å˜ -->
                    <linearGradient id="connectionGradient" x1="0%" y1="0%" x2="100%" y2="0%">
                        <stop offset="0%" style="stop-color:#f1f5f9;stop-opacity:0.8" />
                        <stop offset="100%" style="stop-color:#e2e8f0;stop-opacity:0.8" />
                    </linearGradient>
                    
                    <!-- ç®­å¤´æ ‡è®° -->
                    <marker id="arrowhead" markerWidth="10" markerHeight="7" 
                            refX="9" refY="3.5" orient="auto" markerUnits="strokeWidth">
                        <polygon points="0 0, 10 3.5, 0 7" fill="#007AFF" />
                    </marker>
                    
                    <!-- æ¿€æ´»ç®­å¤´ -->
                    <marker id="activeArrow" markerWidth="12" markerHeight="8" 
                            refX="11" refY="4" orient="auto" markerUnits="strokeWidth">
                        <polygon points="0 0, 12 4, 0 8" fill="url(#activeGradient)" 
                                 filter="drop-shadow(0 2px 4px rgba(0, 122, 255, 0.3))" />
                    </marker>
                </defs>
            </svg>
            <div class="mindmap-container" id="mindmapContainer">
                <!-- æ€ç»´å¯¼å›¾èŠ‚ç‚¹å°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
            </div>
        </div>
    </div>

    <script>
        // æ€ç»´å¯¼å›¾æ•°æ®å·²å®šä¹‰åœ¨æ–‡ä»¶å¼€å¤´

        // Markdownè§£æå™¨ï¼šå°†markdownæ ¼å¼è½¬æ¢ä¸ºåµŒå¥—å¯¹è±¡
        function parseMarkdownToMindmap(markdown) {
            const lines = markdown.split('\n').filter(line => line.trim());
            const root = { id: 'root', text: '', children: [] };
            const stack = [{ node: root, level: -1 }];
            let idCounter = 0;
            
            lines.forEach(line => {
                // è®¡ç®—ç¼©è¿›çº§åˆ«
                const match = line.match(/^(\s*)-\s*(.+)$/);
                if (!match) return;
                
                const indentStr = match[1];
                const text = match[2].trim();
                const level = indentStr.length / 2; // æ¯2ä¸ªç©ºæ ¼ä¸ºä¸€çº§
                
                // ç”Ÿæˆå”¯ä¸€ID
                const id = text === 'å›¾å½¢æ¨ç†æ€è€ƒ' ? 'root' : `node_${++idCounter}`;
                
                const newNode = {
                    id: id,
                    text: text,
                    children: []
                };
                
                // å¦‚æœæ˜¯æ ¹èŠ‚ç‚¹ï¼Œè®¾ç½®æ–‡æœ¬
                if (level === 0) {
                    root.text = text;
                    root.id = 'root';
                    return;
                }
                
                // æ‰¾åˆ°æ­£ç¡®çš„çˆ¶èŠ‚ç‚¹
                while (stack.length > 0 && stack[stack.length - 1].level >= level) {
                    stack.pop();
                }
                
                if (stack.length > 0) {
                    const parent = stack[stack.length - 1].node;
                    parent.children.push(newNode);
                }
                
                // å°†å½“å‰èŠ‚ç‚¹æ¨å…¥æ ˆ
                stack.push({ node: newNode, level: level });
            });
            
            return root;
        }
        
        // è§£æmarkdownæ•°æ®ä¸ºæ€ç»´å¯¼å›¾ç»“æ„
        const mindmapData = parseMarkdownToMindmap(mindmapMarkdown);

        class GingkoMindmapRenderer {
            constructor() {
                this.container = document.getElementById('mindmapContainer');
                this.svg = document.getElementById('connectionSvg');
                this.canvas = document.getElementById('mindmapCanvas');
                this.currentPath = ['root']; // å½“å‰æ´»è·ƒè·¯å¾„
                this.explorationPaths = []; // å­˜å‚¨æ‰€æœ‰æ¢ç´¢è·¯å¾„
                this.solutionPath = null; // æœ€ç»ˆç¡®å®šçš„è§£é¢˜è·¯å¾„
                this.cards = new Map(); // å­˜å‚¨å¡ç‰‡ä¿¡æ¯
                this.scale = 1;
                this.translateX = 0;
                this.translateY = 0;
                this.pathMode = 'exploring'; // 'exploring' | 'confirmed'
                this.keyboardFocusedCard = null; // å½“å‰é”®ç›˜ç„¦ç‚¹çš„å¡ç‰‡ID
                this.positionUpdatePending = false; // è¿æ¥çº¿ä½ç½®æ›´æ–°é˜²æŠ–æ ‡å¿—
                
                this.setupCanvas();
                this.setupKeyboardNavigation();
                this.render();
            }

            setupCanvas() {
                let isDragging = false;
                let startX, startY, startTranslateX, startTranslateY;
                let lastTouchDistance = 0;
                let initialScale = 1;
                let touchStartTime = 0;
                let hasMoved = false;

                // è·å–äº‹ä»¶åæ ‡çš„ç»Ÿä¸€å‡½æ•°
                const getEventCoords = (e) => {
                    if (e.touches && e.touches.length > 0) {
                        return { x: e.touches[0].clientX, y: e.touches[0].clientY };
                    }
                    return { x: e.clientX, y: e.clientY };
                };

                // æ£€æŸ¥æ˜¯å¦å¯ä»¥å¼€å§‹æ‹–åŠ¨ï¼ˆé¿å…åœ¨å¡ç‰‡ä¸Šæ‹–åŠ¨ï¼‰
                const canStartDrag = (target) => {
                    return target === this.canvas || 
                           target === this.svg || 
                           target === this.container ||
                           target.classList.contains('mindmap-container') ||
                           target.classList.contains('mindmap-canvas') ||
                           target.classList.contains('connections-svg');
                };

                // å¼€å§‹æ‹–åŠ¨çš„ç»Ÿä¸€å¤„ç†å‡½æ•°
                const startDrag = (e) => {
                    if (canStartDrag(e.target)) {
                        isDragging = true;
                        hasMoved = false;
                        touchStartTime = Date.now();
                        const coords = getEventCoords(e);
                        startX = coords.x;
                        startY = coords.y;
                        startTranslateX = this.translateX;
                        startTranslateY = this.translateY;
                        
                        // å¯¹äºè§¦æ‘¸äº‹ä»¶ï¼Œå»¶è¿Ÿæ·»åŠ æ‹–åŠ¨çŠ¶æ€ï¼Œä»¥å…å½±å“å¡ç‰‡ç‚¹å‡»
                        if (e.type.startsWith('touch')) {
                            setTimeout(() => {
                                if (isDragging && hasMoved) {
                                    this.canvas.classList.add('dragging');
                                    this.svg.classList.add('dragging');
                                }
                            }, 100);
                        } else {
                            this.canvas.classList.add('dragging');
                            this.svg.classList.add('dragging');
                        }
                    }
                };

                // æ‹–åŠ¨è¿‡ç¨‹çš„ç»Ÿä¸€å¤„ç†å‡½æ•°
                const doDrag = (e) => {
                    if (isDragging) {
                        const coords = getEventCoords(e);
                        const deltaX = coords.x - startX;
                        const deltaY = coords.y - startY;
                        
                        // æ£€æµ‹æ˜¯å¦çœŸçš„åœ¨ç§»åŠ¨ï¼ˆé˜ˆå€¼ä¸º5åƒç´ ï¼‰
                        if (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5) {
                            hasMoved = true;
                            e.preventDefault();
                            
                            this.translateX = startTranslateX + deltaX;
                            this.translateY = startTranslateY + deltaY;
                            this.updateTransform();
                            
                            // å¦‚æœè¿˜æ²¡æœ‰æ·»åŠ æ‹–åŠ¨çŠ¶æ€ï¼Œç°åœ¨æ·»åŠ 
                            if (!this.canvas.classList.contains('dragging')) {
                                this.canvas.classList.add('dragging');
                                this.svg.classList.add('dragging');
                            }
                        }
                    }
                };

                // ç»“æŸæ‹–åŠ¨çš„ç»Ÿä¸€å¤„ç†å‡½æ•°
                const endDrag = () => {
                    if (isDragging) {
                        isDragging = false;
                        this.canvas.classList.remove('dragging');
                        this.svg.classList.remove('dragging');
                        
                        if (hasMoved) {
                            setTimeout(() => {
                                this.updateAllConnectionPositions();
                            }, 50);
                        }
                        
                        hasMoved = false;
                    }
                };

                // é¼ æ ‡äº‹ä»¶
                this.canvas.addEventListener('mousedown', startDrag);
                document.addEventListener('mousemove', doDrag);
                document.addEventListener('mouseup', endDrag);

                // è§¦æ‘¸äº‹ä»¶ - æ”¹è¿›ç‰ˆæœ¬ï¼Œç»‘å®šåˆ°documentä»¥ç¡®ä¿å…¨å±€æ•è·
                document.addEventListener('touchstart', (e) => {
                    // æ£€æŸ¥è§¦æ‘¸æ˜¯å¦åœ¨ç”»å¸ƒåŒºåŸŸå†…
                    const canvasRect = this.canvas.getBoundingClientRect();
                    const touch = e.touches[0];
                    const isInCanvas = touch.clientX >= canvasRect.left && 
                                     touch.clientX <= canvasRect.right && 
                                     touch.clientY >= canvasRect.top && 
                                     touch.clientY <= canvasRect.bottom;
                    
                    if (!isInCanvas) return;
                    
                    if (e.touches.length === 1) {
                        // å•æŒ‡è§¦æ‘¸ï¼šå¯èƒ½æ˜¯æ‹–åŠ¨æˆ–ç‚¹å‡»
                        startDrag(e);
                    } else if (e.touches.length === 2) {
                        // åŒæŒ‡è§¦æ‘¸ï¼šå‡†å¤‡ç¼©æ”¾
                        endDrag(); // å…ˆç»“æŸå¯èƒ½çš„æ‹–åŠ¨
                        const touch1 = e.touches[0];
                        const touch2 = e.touches[1];
                        lastTouchDistance = Math.sqrt(
                            Math.pow(touch2.clientX - touch1.clientX, 2) +
                            Math.pow(touch2.clientY - touch1.clientY, 2)
                        );
                        initialScale = this.scale;
                        this.svg.classList.add('dragging');
                    }
                }, { passive: false });

                document.addEventListener('touchmove', (e) => {
                    if (e.touches.length === 1) {
                        // å•æŒ‡ç§»åŠ¨ï¼šæ‹–åŠ¨
                        doDrag(e);
                    } else if (e.touches.length === 2) {
                        // åŒæŒ‡ç§»åŠ¨ï¼šç¼©æ”¾
                        e.preventDefault();
                        const touch1 = e.touches[0];
                        const touch2 = e.touches[1];
                        const currentDistance = Math.sqrt(
                            Math.pow(touch2.clientX - touch1.clientX, 2) +
                            Math.pow(touch2.clientY - touch1.clientY, 2)
                        );
                        
                        if (lastTouchDistance > 0) {
                            const scaleChange = currentDistance / lastTouchDistance;
                            this.scale = initialScale * scaleChange;
                            this.scale = Math.max(0.5, Math.min(3, this.scale));
                            this.updateTransform();
                        }
                    }
                }, { passive: false });

                document.addEventListener('touchend', (e) => {
                    if (e.touches.length === 0) {
                        // æ‰€æœ‰æ‰‹æŒ‡éƒ½ç¦»å¼€äº†
                        endDrag();
                        lastTouchDistance = 0;
                        clearTimeout(this.scaleTimeout);
                        this.scaleTimeout = setTimeout(() => {
                            this.svg.classList.remove('dragging');
                            this.updateAllConnectionPositions();
                        }, 100);
                    } else if (e.touches.length === 1) {
                        // ä»åŒæŒ‡å˜æˆå•æŒ‡
                        lastTouchDistance = 0;
                        clearTimeout(this.scaleTimeout);
                        this.scaleTimeout = setTimeout(() => {
                            this.svg.classList.remove('dragging');
                            this.updateAllConnectionPositions();
                        }, 100);
                        // é‡æ–°å¼€å§‹å•æŒ‡æ‹–åŠ¨
                        setTimeout(() => {
                            if (e.touches.length === 1) {
                                startDrag(e);
                            }
                        }, 10);
                    }
                }, { passive: false });

                // é˜»æ­¢è§¦æ‘¸æ—¶çš„é»˜è®¤è¡Œä¸ºï¼ˆå¦‚é¡µé¢æ»šåŠ¨ï¼‰
                document.addEventListener('touchcancel', endDrag, { passive: false });

                // é¼ æ ‡æ»šè½®ç¼©æ”¾æ”¯æŒ
                this.canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const delta = e.deltaY > 0 ? 0.9 : 1.1;
                    this.scale *= delta;
                    this.scale = Math.max(0.5, Math.min(3, this.scale));
                    
                    // ç¼©æ”¾æ—¶çŸ­æš‚éšè—è¿æ¥çº¿
                    this.svg.classList.add('dragging');
                    
                    this.updateTransform();
                    
                    // ç¼©æ”¾ç»“æŸåæ¢å¤è¿æ¥çº¿
                    clearTimeout(this.scaleTimeout);
                    this.scaleTimeout = setTimeout(() => {
                        this.svg.classList.remove('dragging');
                        this.updateAllConnectionPositions();
                    }, 100);
                }, { passive: false });
            }

            setupKeyboardNavigation() {
                document.addEventListener('keydown', (e) => {
                    // å¦‚æœå·²ç¡®è®¤è§£å†³æ–¹æ¡ˆï¼Œä¸å…è®¸é”®ç›˜å¯¼èˆª
                    if (this.pathMode === 'confirmed') return;
                    
                    switch(e.key) {
                        case 'ArrowUp':
                            e.preventDefault();
                            this.navigateToSibling('up');
                            break;
                        case 'ArrowDown':
                            e.preventDefault();
                            this.navigateToSibling('down');
                            break;
                        case 'ArrowLeft':
                            e.preventDefault();
                            this.navigateToParent();
                            break;
                        case 'ArrowRight':
                            e.preventDefault();
                            this.navigateToChild();
                            break;
                        case 'Enter':
                            e.preventDefault();
                            this.selectFocusedCard();
                            break;
                        case 'Escape':
                            e.preventDefault();
                            this.clearKeyboardFocus();
                            break;
                    }
                });

                // é¼ æ ‡ç‚¹å‡»æ—¶è®¾ç½®é”®ç›˜ç„¦ç‚¹ï¼ˆä½†ä¸æ¸…é™¤ï¼Œè®©é”®ç›˜å¯¼èˆªæ›´è¿è´¯ï¼‰
                this.canvas.addEventListener('click', (e) => {
                    const clickedCard = e.target.closest('.card');
                    if (clickedCard && !clickedCard.classList.contains('hidden')) {
                        this.setKeyboardFocus(clickedCard.dataset.nodeId);
                    }
                });
            }

            updateTransform() {
                const transform = `translate(${this.translateX}px, ${this.translateY}px) scale(${this.scale})`;
                this.container.style.transform = transform;
                // SVGä¹Ÿéœ€è¦è·Ÿéšç›¸åŒçš„å˜æ¢ï¼Œè¿™æ ·è¿æ¥çº¿åæ ‡ç³»ç»Ÿå°±èƒ½ä¸å¡ç‰‡ä¿æŒä¸€è‡´
                this.svg.style.transform = transform;
            }

            render() {
                console.log('=== Gingkoæ¸²æŸ“å¼€å§‹ ===');
                this.container.innerHTML = '';
                this.svg.innerHTML = '';
                this.cards.clear();
                this.currentPath = ['root'];
                
                // åˆ›å»ºGingkoé£æ ¼çš„åˆ—å¸ƒå±€
                this.createGingkoLayout();
                
                // å…ˆå±…ä¸­ç”»å¸ƒï¼Œé¿å…é¦–æ¬¡ç»˜åˆ¶ä½ç½®åå·®
                this.centerView();
                
                // æ›´æ–°æ˜¾ç¤ºçŠ¶æ€ï¼ˆåœ¨å±…ä¸­ä¹‹åï¼‰
                this.updateDisplay();
                
                // é¦–æ¬¡æ¸²æŸ“ä¸æ˜¾ç¤ºè¿æ¥çº¿ï¼Œç­‰ç”¨æˆ·äº¤äº’åå†æ˜¾ç¤º
                this.svg.classList.remove('visible');
            }

            createGingkoLayout() {
                // é€’å½’åˆ›å»ºæ‰€æœ‰å¡ç‰‡ï¼Œä½¿ç”¨ç»å¯¹å®šä½
                this.createCardsRecursively(mindmapData, 0, 100, 100);
            }

            createCardsRecursively(nodeData, level, x, y) {
                // åˆ›å»ºå½“å‰å¡ç‰‡
                this.createCard(nodeData, level, x, y);
                
                // é€’å½’åˆ›å»ºå­å¡ç‰‡
                if (nodeData.children && nodeData.children.length > 0) {
                    const childX = x + 300; // æ¯åˆ—é—´è·300px
                    const childSpacing = 80; // æ¯ä¸ªå­å¡ç‰‡é—´è·80px
                    const totalHeight = (nodeData.children.length - 1) * childSpacing;
                    const startY = y - totalHeight / 2;
                    
                    nodeData.children.forEach((child, index) => {
                        const childY = startY + index * childSpacing;
                        this.createCardsRecursively(child, level + 1, childX, childY);
                    });
                }
            }

            createCard(nodeData, level, x, y) {
                const card = document.createElement('div');
                card.className = `card ${level === 0 ? 'root-card' : level === 1 ? 'branch-card' : 'leaf-card'}`;
                card.dataset.nodeId = nodeData.id;
                card.dataset.level = level;
                
                // è®¾ç½®ç»å¯¹ä½ç½®
                card.style.left = x + 'px';
                card.style.top = y + 'px';
                
                // é»˜è®¤éšè—éæ ¹èŠ‚ç‚¹
                if (level > 0) {
                    card.classList.add('hidden');
                }

                const content = document.createElement('div');
                content.className = 'card-content';
                content.textContent = nodeData.text;

                // æ·»åŠ å­èŠ‚ç‚¹æ•°é‡æŒ‡ç¤ºå™¨
                if (nodeData.children && nodeData.children.length > 0) {
                    const indicator = document.createElement('div');
                    indicator.className = 'expand-indicator';
                    indicator.textContent = nodeData.children.length;
                    card.appendChild(indicator);
                }

                card.appendChild(content);
                
                // æ·»åŠ ç‚¹å‡»äº‹ä»¶
                card.addEventListener('click', (e) => {
                    e.stopPropagation();
                    console.log('ç‚¹å‡»å¡ç‰‡:', nodeData.id);
                    this.handleCardClick(nodeData.id);
                    // ç‚¹å‡»åè®¾ç½®é”®ç›˜ç„¦ç‚¹ï¼ˆåœ¨handleCardClickä¹‹åï¼Œç¡®ä¿ç•Œé¢å·²æ›´æ–°ï¼‰
                    setTimeout(() => {
                        this.setKeyboardFocus(nodeData.id);
                    }, 50);
                });

                // æ·»åŠ æ‚¬åœäº‹ä»¶ï¼ˆä»…å¯¹æ¢ç´¢è·¯å¾„å¡ç‰‡ï¼‰
                card.addEventListener('mouseenter', (e) => {
                    if (card.classList.contains('exploration')) {
                        this.highlightExplorationPath(nodeData.id);
                    }
                });

                card.addEventListener('mouseleave', (e) => {
                    if (card.classList.contains('exploration')) {
                        this.unhighlightExplorationPath();
                    }
                });

                this.container.appendChild(card);

                // ä¿å­˜å¡ç‰‡ä¿¡æ¯
                this.cards.set(nodeData.id, {
                    element: card,
                    data: nodeData,
                    level: level,
                    x: x,
                    y: y
                });
                
                // åˆ›å»ºè¿æ¥çº¿ï¼ˆå¦‚æœæœ‰çˆ¶èŠ‚ç‚¹ï¼‰
                if (level > 0) {
                    this.createConnection(nodeData, level, x, y);
                }
            }

            createConnection(nodeData, level, x, y) {
                // æ‰¾åˆ°çˆ¶èŠ‚ç‚¹ä½ç½®
                const parentCard = this.findParentCard(nodeData.id);
                if (!parentCard) return;

                const line = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                line.setAttribute('class', 'connection-line');
                line.dataset.from = parentCard.data.id;
                line.dataset.to = nodeData.id;

                this.svg.appendChild(line);
            }

            // æ›´æ–°æ‰€æœ‰è¿æ¥çº¿çš„å®é™…ä½ç½®
            updateAllConnectionPositions() {
                // ä½¿ç”¨requestAnimationFrameä¼˜åŒ–æ€§èƒ½ï¼Œé¿å…æ‹–åŠ¨æ—¶è¿‡åº¦é‡ç»˜
                if (this.positionUpdatePending) return;
                
                this.positionUpdatePending = true;
                requestAnimationFrame(() => {
                const lines = this.svg.querySelectorAll('.connection-line');
                
                lines.forEach((line) => {
                    const fromId = line.dataset.from;
                    const toId = line.dataset.to;
                    
                    const fromCard = this.cards.get(fromId);
                    const toCard = this.cards.get(toId);
                    
                    if (fromCard && toCard && fromCard.element && toCard.element) {
                        // æ£€æŸ¥å…ƒç´ æ˜¯å¦å¯è§
                        if (fromCard.element.classList.contains('hidden') || toCard.element.classList.contains('hidden')) {
                            return;
                        }
                        
                            // ä½¿ç”¨å­˜å‚¨çš„åæ ‡è€Œä¸æ˜¯getBoundingClientRect
                            // å› ä¸ºtransformä¼šå½±å“getBoundingClientRectçš„ç»“æœ
                            const fromX = fromCard.x + 240; // å¡ç‰‡å®½åº¦240pxï¼Œè¿æ¥ç‚¹åœ¨å³è¾¹
                            const fromY = fromCard.y + 40; // è¿æ¥ç‚¹åœ¨å¡ç‰‡ä¸­å¿ƒï¼ˆå¡ç‰‡é«˜åº¦çº¦80pxï¼‰
                            const toX = toCard.x; // è¿æ¥ç‚¹åœ¨å·¦è¾¹
                            const toY = toCard.y + 40; // è¿æ¥ç‚¹åœ¨å¡ç‰‡ä¸­å¿ƒ
                        
                        // åˆ›å»ºè¿æ¥è·¯å¾„
                        const path = this.createSmoothCurvePath(fromX, fromY, toX, toY);
                        line.setAttribute('d', path);
                    }
                    });
                    
                    this.positionUpdatePending = false;
                });
            }

            createSmoothCurvePath(x1, y1, x2, y2) {
                // åˆ›å»ºæµç•…çš„Så‹è´å¡å°”æ›²çº¿
                const dx = x2 - x1;
                const dy = y2 - y1;
                
                // æ§åˆ¶ç‚¹ä½ç½®ï¼Œåˆ›é€ è‡ªç„¶çš„æ›²çº¿
                const cp1x = x1 + dx * 0.6;
                const cp1y = y1;
                const cp2x = x1 + dx * 0.4;
                const cp2y = y2;
                
                return `M ${x1} ${y1} C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${x2} ${y2}`;
            }

            findParentCard(nodeId) {
                // åœ¨æ•°æ®ç»“æ„ä¸­æ‰¾åˆ°çˆ¶èŠ‚ç‚¹
                const findParent = (node, targetId, parent = null) => {
                    if (node.id === targetId) {
                        return parent;
                    }
                    if (node.children) {
                        for (const child of node.children) {
                            const result = findParent(child, targetId, node);
                            if (result) return result;
                        }
                    }
                    return null;
                };
                
                const parentData = findParent(mindmapData, nodeId);
                return parentData ? this.cards.get(parentData.id) : null;
            }

            handleCardClick(nodeId) {
                console.log('=== å¤„ç†å¡ç‰‡ç‚¹å‡» ===');
                console.log('ç‚¹å‡»å¡ç‰‡:', nodeId);
                console.log('å½“å‰è·¯å¾„:', this.currentPath);
                
                // é¦–æ¬¡ç‚¹å‡»æ—¶æ˜¾ç¤ºè¿æ¥çº¿
                if (!this.svg.classList.contains('visible')) {
                    this.svg.classList.add('visible');
                }
                
                // å¦‚æœå·²ç»ç¡®è®¤äº†è§£å†³æ–¹æ¡ˆï¼Œä¸å…è®¸å†ä¿®æ”¹
                if (this.pathMode === 'confirmed') {
                    console.log('è§£å†³æ–¹æ¡ˆå·²ç¡®è®¤ï¼Œæ— æ³•ä¿®æ”¹è·¯å¾„');
                    return;
                }
                
                // æ„å»ºåˆ°ç›®æ ‡èŠ‚ç‚¹çš„è·¯å¾„
                const newPath = this.buildPathToNode(nodeId);
                if (newPath) {
                    this.currentPath = newPath;
                    console.log('æ–°è·¯å¾„:', this.currentPath);
                    this.updateDisplay();
                } else {
                    console.log('æ— æ³•æ‰¾åˆ°èŠ‚ç‚¹è·¯å¾„');
                }
            }

            // æ„å»ºä»æ ¹èŠ‚ç‚¹åˆ°ç›®æ ‡èŠ‚ç‚¹çš„å®Œæ•´è·¯å¾„
            buildPathToNode(targetId) {
                return this.findPathInData(mindmapData, targetId, []);
            }

            // åœ¨æ•°æ®ç»“æ„ä¸­æŸ¥æ‰¾è·¯å¾„
            findPathInData(node, targetId, currentPath) {
                const newPath = [...currentPath, node.id];
                
                if (node.id === targetId) {
                    return newPath;
                }
                
                if (node.children) {
                    for (const child of node.children) {
                        const result = this.findPathInData(child, targetId, newPath);
                        if (result) {
                            return result;
                        }
                    }
                }
                
                return null;
            }

            updateDisplay() {
                console.log('=== æ›´æ–°Gingkoæ˜¾ç¤º ===');
                console.log('å½“å‰è·¯å¾„:', this.currentPath);
                console.log('æ¢ç´¢è·¯å¾„:', this.explorationPaths);
                console.log('è§£å†³æ–¹æ¡ˆè·¯å¾„:', this.solutionPath);
                
                // 1. é‡ç½®æ‰€æœ‰å¡ç‰‡çŠ¶æ€
                this.cards.forEach((cardInfo, nodeId) => {
                    cardInfo.element.classList.add('hidden');
                    cardInfo.element.classList.remove('active', 'exploration', 'solution');
                });

                // 2. æ˜¾ç¤ºå¹¶æ ‡è®°æ‰€æœ‰æ¢ç´¢è·¯å¾„ä¸­çš„å¡ç‰‡
                this.explorationPaths.forEach(path => {
                    path.forEach((nodeId) => {
                    const cardInfo = this.cards.get(nodeId);
                    if (cardInfo) {
                        cardInfo.element.classList.remove('hidden');
                            cardInfo.element.classList.add('exploration');
                        }
                    });
                });

                // 3. æ˜¾ç¤ºå¹¶æ ‡è®°è§£å†³æ–¹æ¡ˆè·¯å¾„ä¸­çš„å¡ç‰‡ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                if (this.solutionPath) {
                    this.solutionPath.forEach((nodeId) => {
                        const cardInfo = this.cards.get(nodeId);
                        if (cardInfo) {
                            cardInfo.element.classList.remove('hidden', 'exploration');
                            cardInfo.element.classList.add('solution');
                        }
                    });
                }

                // 4. æ˜¾ç¤ºå½“å‰æ´»è·ƒè·¯å¾„ä¸­çš„å¡ç‰‡
                if (this.pathMode === 'exploring') {
                    this.currentPath.forEach((nodeId) => {
                        const cardInfo = this.cards.get(nodeId);
                        if (cardInfo) {
                            cardInfo.element.classList.remove('hidden', 'exploration');
                        cardInfo.element.classList.add('active');
                    }
                });

                    // 5. æ˜¾ç¤ºå½“å‰èŠ‚ç‚¹çš„ç›´æ¥å­èŠ‚ç‚¹
                const currentNodeId = this.currentPath[this.currentPath.length - 1];
                const currentNode = this.findNodeInData(mindmapData, currentNodeId);
                
                if (currentNode && currentNode.children) {
                    currentNode.children.forEach(child => {
                        const childCardInfo = this.cards.get(child.id);
                        if (childCardInfo) {
                            childCardInfo.element.classList.remove('hidden');
                                }
                            });
                    }
                        }
                
                // æ›´æ–°è¿æ¥çº¿ä½ç½®å’Œæ˜¾ç¤ºçŠ¶æ€ï¼ˆåªåœ¨è¿æ¥çº¿å¯è§æ—¶ï¼‰
                if (this.svg.classList.contains('visible')) {
                    setTimeout(() => {
                        this.updateAllConnectionPositions();
                        this.updateConnectionLines();
                    }, 50); // ç­‰å¾…DOMæ›´æ–°å®Œæˆ
                }
            }

            updateConnectionLines() {
                // å…ˆæ›´æ–°æ‰€æœ‰è¿æ¥çº¿ä½ç½®
                this.updateAllConnectionPositions();
                
                // è·å–æ‰€æœ‰è¿æ¥çº¿
                const lines = this.svg.querySelectorAll('.connection-line');
                
                // é‡ç½®æ‰€æœ‰è¿æ¥çº¿çŠ¶æ€
                lines.forEach(line => {
                    line.classList.remove('visible', 'active', 'exploration', 'solution');
                    line.setAttribute('marker-end', 'url(#arrowhead)');
                });

                // æ˜¾ç¤ºæ¢ç´¢è·¯å¾„çš„è¿æ¥çº¿
                this.explorationPaths.forEach(path => {
                    for (let i = 0; i < path.length - 1; i++) {
                        const fromId = path[i];
                        const toId = path[i + 1];
                        
                        const pathLine = Array.from(lines).find(line => 
                            line.dataset.from === fromId && line.dataset.to === toId
                        );
                        
                        if (pathLine) {
                            pathLine.classList.add('visible', 'exploration');
                        }
                    }
                });

                // æ˜¾ç¤ºè§£å†³æ–¹æ¡ˆè·¯å¾„çš„è¿æ¥çº¿ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                if (this.solutionPath) {
                    for (let i = 0; i < this.solutionPath.length - 1; i++) {
                        const fromId = this.solutionPath[i];
                        const toId = this.solutionPath[i + 1];
                        
                        const pathLine = Array.from(lines).find(line => 
                            line.dataset.from === fromId && line.dataset.to === toId
                        );
                        
                        if (pathLine) {
                            pathLine.classList.remove('exploration');
                            pathLine.classList.add('visible', 'solution');
                            pathLine.setAttribute('marker-end', 'url(#activeArrow)');
                        }
                    }
                }

                // æ˜¾ç¤ºå½“å‰æ´»è·ƒè·¯å¾„çš„è¿æ¥çº¿
                if (this.pathMode === 'exploring') {
                for (let i = 0; i < this.currentPath.length - 1; i++) {
                    const fromId = this.currentPath[i];
                    const toId = this.currentPath[i + 1];
                    
                    const pathLine = Array.from(lines).find(line => 
                        line.dataset.from === fromId && line.dataset.to === toId
                    );
                    
                    if (pathLine) {
                            pathLine.classList.remove('exploration');
                        pathLine.classList.add('visible', 'active');
                        pathLine.setAttribute('marker-end', 'url(#activeArrow)');
                    }
                }

                // æ˜¾ç¤ºå½“å‰èŠ‚ç‚¹çš„å­è¿æ¥çº¿
                const currentNodeId = this.currentPath[this.currentPath.length - 1];
                const currentNode = this.findNodeInData(mindmapData, currentNodeId);
                
                if (currentNode && currentNode.children) {
                    currentNode.children.forEach(child => {
                        const childLine = Array.from(lines).find(line => 
                            line.dataset.from === currentNodeId && line.dataset.to === child.id
                        );
                        
                        if (childLine) {
                            childLine.classList.add('visible');
                    }
                });
                    }
            }
            }

            // åœ¨æ•°æ®ç»“æ„ä¸­æŸ¥æ‰¾èŠ‚ç‚¹
            findNodeInData(node, targetId) {
                if (node.id === targetId) {
                    return node;
                }
                
                if (node.children) {
                    for (const child of node.children) {
                        const result = this.findNodeInData(child, targetId);
                        if (result) {
                            return result;
                        }
                    }
                }
                
                return null;
            }


            centerView() {
                this.scale = 1.0;
                this.translateX = 50; // è®©æ ¹å¡ç‰‡æ˜¾ç¤ºåœ¨å·¦ä¾§åˆé€‚ä½ç½®
                this.translateY = window.innerHeight / 2 - 150; // å‚ç›´å±…ä¸­
                this.updateTransform();
            }

            goBackOneStep() {
                if (this.pathMode === 'confirmed') {
                    console.log('è§£å†³æ–¹æ¡ˆå·²ç¡®è®¤ï¼Œæ— æ³•å›é€€');
                    return;
                }
                
                if (this.currentPath.length > 1) {
                    this.currentPath.pop(); // ç§»é™¤æœ€åä¸€ä¸ªèŠ‚ç‚¹
                    this.updateDisplay();
                }
            }

            // å°è¯•å¦ä¸€æ¡è·¯å¾„ï¼ˆå°†å½“å‰è·¯å¾„åŠ å…¥æ¢ç´¢è·¯å¾„ï¼‰
            tryAnotherPath() {
                if (this.pathMode === 'confirmed') {
                    console.log('è§£å†³æ–¹æ¡ˆå·²ç¡®è®¤ï¼Œæ— æ³•å°è¯•æ–°è·¯å¾„');
                    return;
                }
                
                if (this.currentPath.length > 1) {
                    // å°†å½“å‰è·¯å¾„åŠ å…¥æ¢ç´¢è·¯å¾„
                    this.explorationPaths.push([...this.currentPath]);
                    console.log('å°†è·¯å¾„åŠ å…¥æ¢ç´¢:', this.currentPath);
                    
                    // é‡ç½®åˆ°æ ¹èŠ‚ç‚¹
                    this.currentPath = ['root'];
                    this.updateDisplay();
                }
            }

            // ç¡®è®¤å½“å‰è·¯å¾„ä¸ºè§£å†³æ–¹æ¡ˆ
            confirmSolution() {
                if (this.currentPath.length > 1) {
                    this.solutionPath = [...this.currentPath];
                    this.pathMode = 'confirmed';
                    console.log('ç¡®è®¤è§£å†³æ–¹æ¡ˆè·¯å¾„:', this.solutionPath);
                    this.updateDisplay();
                    
                    // æ˜¾ç¤ºå¤åˆ¶æŒ‰é’®
                    document.getElementById('copyBtn').style.display = 'block';
                }
            }

            // é‡ç½®æ‰€æœ‰çŠ¶æ€
            resetToInitialState() {
                this.currentPath = ['root'];
                this.explorationPaths = [];
                this.solutionPath = null;
                this.pathMode = 'exploring';
                this.clearKeyboardFocus();
                this.svg.classList.remove('visible');
                
                // éšè—å¤åˆ¶æŒ‰é’®
                document.getElementById('copyBtn').style.display = 'none';
                
                this.updateDisplay();
            }

            // é«˜äº®æ˜¾ç¤ºç‰¹å®šçš„æ¢ç´¢è·¯å¾„
            highlightExplorationPath(nodeId) {
                // æ‰¾åˆ°åŒ…å«è¯¥èŠ‚ç‚¹çš„æ¢ç´¢è·¯å¾„
                const targetPath = this.explorationPaths.find(path => path.includes(nodeId));
                if (!targetPath) return;

                // é«˜äº®è¯¥è·¯å¾„ä¸Šçš„æ‰€æœ‰å¡ç‰‡
                targetPath.forEach(pathNodeId => {
                    const cardInfo = this.cards.get(pathNodeId);
                    if (cardInfo && cardInfo.element.classList.contains('exploration')) {
                        cardInfo.element.classList.add('highlighted');
                    }
                });

                // é«˜äº®è¯¥è·¯å¾„ä¸Šçš„æ‰€æœ‰è¿æ¥çº¿
                const lines = this.svg.querySelectorAll('.connection-line');
                for (let i = 0; i < targetPath.length - 1; i++) {
                    const fromId = targetPath[i];
                    const toId = targetPath[i + 1];
                    
                    const pathLine = Array.from(lines).find(line => 
                        line.dataset.from === fromId && line.dataset.to === toId
                    );
                    
                    if (pathLine && pathLine.classList.contains('exploration')) {
                        pathLine.classList.add('highlighted');
                    }
                }
            }

            // å–æ¶ˆé«˜äº®æ¢ç´¢è·¯å¾„
            unhighlightExplorationPath() {
                // ç§»é™¤æ‰€æœ‰å¡ç‰‡çš„é«˜äº®çŠ¶æ€
                this.cards.forEach((cardInfo) => {
                    cardInfo.element.classList.remove('highlighted');
                });

                // ç§»é™¤æ‰€æœ‰è¿æ¥çº¿çš„é«˜äº®çŠ¶æ€
                const lines = this.svg.querySelectorAll('.connection-line');
                lines.forEach(line => {
                    line.classList.remove('highlighted');
                });
            }

            // åŒçº§èŠ‚ç‚¹å¯¼èˆªï¼ˆä¸Šä¸‹é”®ï¼‰
            navigateToSibling(direction) {
                // å¦‚æœæ²¡æœ‰ç„¦ç‚¹ï¼Œå…ˆå°è¯•ä»å¯è§çš„å­èŠ‚ç‚¹å¼€å§‹
                if (!this.keyboardFocusedCard) {
                    this.initializeKeyboardFocus();
                    return;
                }

                // è·å–å½“å‰ç„¦ç‚¹èŠ‚ç‚¹çš„åŒçº§èŠ‚ç‚¹
                const siblings = this.getSiblingsOfNode(this.keyboardFocusedCard);
                if (siblings.length <= 1) return; // æ²¡æœ‰å…„å¼ŸèŠ‚ç‚¹å¯ä»¥åˆ‡æ¢

                const currentIndex = siblings.findIndex(sibling => sibling.id === this.keyboardFocusedCard);
                if (currentIndex === -1) return; // å½“å‰èŠ‚ç‚¹ä¸åœ¨å…„å¼ŸèŠ‚ç‚¹åˆ—è¡¨ä¸­

                // æ ¹æ®æ–¹å‘è®¡ç®—æ–°çš„ç´¢å¼•
                let newIndex;
                if (direction === 'down') {
                    newIndex = (currentIndex + 1) % siblings.length;
                } else {
                    newIndex = currentIndex === 0 ? siblings.length - 1 : currentIndex - 1;
                }

                // è®¾ç½®æ–°çš„ç„¦ç‚¹
                this.setKeyboardFocus(siblings[newIndex].id);
            }

            // å¯¼èˆªåˆ°çˆ¶èŠ‚ç‚¹ï¼ˆå·¦é”®ï¼‰
            navigateToParent() {
                if (!this.keyboardFocusedCard) {
                    // å¦‚æœæ²¡æœ‰ç„¦ç‚¹ï¼Œè®¾ç½®ç„¦ç‚¹åˆ°å½“å‰è·¯å¾„çš„æœ€åä¸€ä¸ªèŠ‚ç‚¹
                    const lastNodeId = this.currentPath[this.currentPath.length - 1];
                    this.setKeyboardFocus(lastNodeId);
                    return;
                }

                // æ‰¾åˆ°å½“å‰ç„¦ç‚¹èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹
                const parentNode = this.findParentInData(this.keyboardFocusedCard);
                if (parentNode && this.isNodeVisible(parentNode.id)) {
                    this.setKeyboardFocus(parentNode.id);
                } else {
                    // å¦‚æœçˆ¶èŠ‚ç‚¹ä¸å¯è§ï¼Œå°è¯•å›åˆ°è·¯å¾„ä¸­çš„ä¸Šä¸€çº§
                    const focusedIndex = this.currentPath.indexOf(this.keyboardFocusedCard);
                    if (focusedIndex > 0) {
                        this.setKeyboardFocus(this.currentPath[focusedIndex - 1]);
                    }
                }
            }

            // å¯¼èˆªåˆ°å­èŠ‚ç‚¹ï¼ˆå³é”®ï¼‰
            navigateToChild() {
                if (!this.keyboardFocusedCard) {
                    this.initializeKeyboardFocus();
                    return;
                }

                // æ£€æŸ¥å½“å‰ç„¦ç‚¹èŠ‚ç‚¹æ˜¯å¦æœ‰å¯è§çš„å­èŠ‚ç‚¹
                const focusedNodeData = this.findNodeInData(mindmapData, this.keyboardFocusedCard);
                if (!focusedNodeData || !focusedNodeData.children) return;

                // æ‰¾åˆ°ç¬¬ä¸€ä¸ªå¯è§çš„å­èŠ‚ç‚¹
                const firstVisibleChild = focusedNodeData.children.find(child => 
                    this.isNodeVisible(child.id)
                );

                if (firstVisibleChild) {
                    this.setKeyboardFocus(firstVisibleChild.id);
                } else {
                    // å¦‚æœæ²¡æœ‰å¯è§çš„å­èŠ‚ç‚¹ï¼Œå°è¯•å±•å¼€/é€‰æ‹©å½“å‰èŠ‚ç‚¹
                    this.selectFocusedCard();
                }
            }

            // åˆå§‹åŒ–é”®ç›˜ç„¦ç‚¹ï¼ˆè®¾ç½®åˆ°ç¬¬ä¸€ä¸ªå¯è§çš„å¯é€‰æ‹©èŠ‚ç‚¹ï¼‰
            initializeKeyboardFocus() {
                // ä¼˜å…ˆé€‰æ‹©å½“å‰è·¯å¾„çš„æœ€åä¸€ä¸ªèŠ‚ç‚¹
                const lastNodeId = this.currentPath[this.currentPath.length - 1];
                if (this.isNodeVisible(lastNodeId)) {
                    this.setKeyboardFocus(lastNodeId);
                    return;
                }

                // å¦åˆ™é€‰æ‹©ç¬¬ä¸€ä¸ªå¯è§çš„å­èŠ‚ç‚¹
                const lastNode = this.findNodeInData(mindmapData, lastNodeId);
                if (lastNode && lastNode.children) {
                    const firstVisibleChild = lastNode.children.find(child => 
                        this.isNodeVisible(child.id)
                    );
                    if (firstVisibleChild) {
                        this.setKeyboardFocus(firstVisibleChild.id);
                    }
                }
            }

            // è·å–æŒ‡å®šèŠ‚ç‚¹çš„åŒçº§èŠ‚ç‚¹
            getSiblingsOfNode(nodeId) {
                const parentNode = this.findParentInData(nodeId);
                if (!parentNode || !parentNode.children) return [];

                // æ‰¾åˆ°çˆ¶èŠ‚ç‚¹ä¸‹æ‰€æœ‰å¯è§çš„å­èŠ‚ç‚¹
                const siblings = parentNode.children
                    .filter(child => this.isNodeVisible(child.id))
                    .map(child => {
                        const cardInfo = this.cards.get(child.id);
                        return {
                            id: child.id,
                            data: child,
                            y: cardInfo ? cardInfo.y : 0
                        };
                    });

                // æŒ‰Yåæ ‡æ’åºï¼ˆä»ä¸Šåˆ°ä¸‹ï¼‰
                siblings.sort((a, b) => a.y - b.y);
                return siblings;
            }

            // æ£€æŸ¥èŠ‚ç‚¹æ˜¯å¦å¯è§
            isNodeVisible(nodeId) {
                const cardInfo = this.cards.get(nodeId);
                return cardInfo && !cardInfo.element.classList.contains('hidden');
            }


            // åœ¨æ•°æ®ç»“æ„ä¸­æ‰¾åˆ°æŸä¸ªèŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹
            findParentInData(targetId) {
                const findParent = (node, target, parent = null) => {
                    if (node.id === target) {
                        return parent;
                    }
                    if (node.children) {
                        for (const child of node.children) {
                            const result = findParent(child, target, node);
                            if (result) return result;
                        }
                    }
                    return null;
                };
                
                return findParent(mindmapData, targetId);
            }

            // è®¾ç½®é”®ç›˜ç„¦ç‚¹
            setKeyboardFocus(nodeId) {
                // æ¸…é™¤ä¹‹å‰çš„ç„¦ç‚¹
                this.clearKeyboardFocus();
                
                // è®¾ç½®æ–°ç„¦ç‚¹
                this.keyboardFocusedCard = nodeId;
                const cardInfo = this.cards.get(nodeId);
                if (cardInfo) {
                    cardInfo.element.classList.add('keyboard-focused');
                    console.log('é”®ç›˜ç„¦ç‚¹è®¾ç½®åˆ°:', nodeId);
                }
            }

            // æ¸…é™¤é”®ç›˜ç„¦ç‚¹
            clearKeyboardFocus() {
                if (this.keyboardFocusedCard) {
                    const cardInfo = this.cards.get(this.keyboardFocusedCard);
                    if (cardInfo) {
                        cardInfo.element.classList.remove('keyboard-focused');
                    }
                    this.keyboardFocusedCard = null;
                }
            }

            // é€‰æ‹©å½“å‰ç„¦ç‚¹çš„å¡ç‰‡
            selectFocusedCard() {
                if (this.keyboardFocusedCard) {
                    this.handleCardClick(this.keyboardFocusedCard);
                    // é€‰æ‹©åï¼Œè‡ªåŠ¨è®¾ç½®ç„¦ç‚¹åˆ°æ–°å±•å¼€çš„ç¬¬ä¸€ä¸ªå­èŠ‚ç‚¹ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰
                    setTimeout(() => {
                        const focusedNodeData = this.findNodeInData(mindmapData, this.keyboardFocusedCard);
                        if (focusedNodeData && focusedNodeData.children) {
                            const firstVisibleChild = focusedNodeData.children.find(child => 
                                this.isNodeVisible(child.id)
                            );
                            if (firstVisibleChild) {
                                this.setKeyboardFocus(firstVisibleChild.id);
                            }
                        }
                    }, 100);
                }
            }

            // ç”Ÿæˆè§£æ³•è·¯å¾„æ–‡æœ¬
            generateSolutionText() {
                if (!this.solutionPath || this.solutionPath.length === 0) {
                    return "æš‚æ— è§£æ³•è·¯å¾„";
                }

                // åªè¿”å›çº¯ç²¹çš„è§£é¢˜è·¯å¾„
                const solutionText = this.solutionPath.slice(1).map(nodeId => {
                    const nodeData = this.findNodeInData(mindmapData, nodeId);
                    return nodeData ? nodeData.text : nodeId;
                }).join(' â†’ ');

                return solutionText;
            }

            // å¤åˆ¶è§£æ³•è·¯å¾„åˆ°å‰ªè´´æ¿
            async copySolutionToClipboard() {
                const solutionText = this.generateSolutionText();
                
                try {
                    await navigator.clipboard.writeText(solutionText);
                    return true;
                } catch (err) {
                    // é™çº§æ–¹æ¡ˆï¼šä½¿ç”¨ä¼ ç»Ÿçš„å¤åˆ¶æ–¹æ³•
                    const textArea = document.createElement('textarea');
                    textArea.value = solutionText;
                    textArea.style.position = 'fixed';
                    textArea.style.left = '-999999px';
                    textArea.style.top = '-999999px';
                    document.body.appendChild(textArea);
                    textArea.focus();
                    textArea.select();
                    
                    try {
                        document.execCommand('copy');
                        document.body.removeChild(textArea);
                        return true;
                    } catch (err2) {
                        document.body.removeChild(textArea);
                        return false;
                    }
                }
            }
        }

        // å…¨å±€å‡½æ•°
        function resetMindmap() {
            if (window.mindmapRenderer) {
                window.mindmapRenderer.resetToInitialState();
            } else {
            location.reload();
            }
        }

        function centerView() {
            if (window.mindmapRenderer) {
                window.mindmapRenderer.centerView();
            }
        }


        function tryAnotherPath() {
            if (window.mindmapRenderer) {
                window.mindmapRenderer.tryAnotherPath();
            }
        }

        function confirmSolution() {
            if (window.mindmapRenderer) {
                window.mindmapRenderer.confirmSolution();
            }
        }

        async function copySolutionPath() {
            if (window.mindmapRenderer) {
                const copyBtn = document.getElementById('copyBtn');
                const originalText = copyBtn.textContent;
                
                try {
                    const success = await window.mindmapRenderer.copySolutionToClipboard();
                    
                    if (success) {
                        // æ˜¾ç¤ºæˆåŠŸåé¦ˆ
                        copyBtn.textContent = 'âœ… å·²å¤åˆ¶';
                        copyBtn.classList.add('copied');
                        
                        // 2ç§’åæ¢å¤åŸçŠ¶
                        setTimeout(() => {
                            copyBtn.textContent = originalText;
                            copyBtn.classList.remove('copied');
                        }, 2000);
                    } else {
                        // æ˜¾ç¤ºå¤±è´¥åé¦ˆ
                        copyBtn.textContent = 'âŒ å¤åˆ¶å¤±è´¥';
                        setTimeout(() => {
                            copyBtn.textContent = originalText;
                        }, 2000);
                    }
                } catch (error) {
                    console.error('å¤åˆ¶å¤±è´¥:', error);
                    copyBtn.textContent = 'âŒ å¤åˆ¶å¤±è´¥';
                    setTimeout(() => {
                        copyBtn.textContent = originalText;
                    }, 2000);
                }
            }
        }

        // åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', () => {
            window.mindmapRenderer = new GingkoMindmapRenderer();
        });

        // é”®ç›˜å¿«æ·é”®
        document.addEventListener('keydown', (e) => {
            if (e.key === 'F5' || (e.metaKey && e.key === 'r') || (e.ctrlKey && e.key === 'r')) {
                return; // å…è®¸åˆ·æ–°
            }
            if (e.key === 'c' || e.key === 'C') {
                centerView();
            }
            // ç§»é™¤äº†å›é€€é”®å¤„ç†ï¼Œç°åœ¨ç”±é”®ç›˜å¯¼èˆªç³»ç»Ÿç»Ÿä¸€å¤„ç†æ–¹å‘é”®
        });
    </script>
</body>
</html>
